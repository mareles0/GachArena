{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Deferred } from '@firebase/util';\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\n\nclass Component {\n  /**\n   *\n   * @param name The public service name, e.g. app, auth, firestore, database\n   * @param instanceFactory Service factory responsible for creating the public interface\n   * @param type whether the service provided by the component is public or private\n   */\n  constructor(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\n     * Properties to be added to the service namespace\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* InstantiationMode.LAZY */\n    ;\n    this.onInstanceCreated = null;\n  }\n\n  setInstantiationMode(mode) {\n    this.instantiationMode = mode;\n    return this;\n  }\n\n  setMultipleInstances(multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n\n  setServiceProps(props) {\n    this.serviceProps = props;\n    return this;\n  }\n\n  setInstanceCreatedCallback(callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  }\n\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\n\nclass Provider {\n  constructor(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\n   * @param identifier A provider can provide multiple instances of a service\n   * if this.component.multipleInstances is true.\n   */\n\n\n  get(identifier) {\n    // if multipleInstances is not supported, use the default name\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      const deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  }\n\n  getImmediate(options) {\n    // if multipleInstances is not supported, use the default name\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(options?.identifier);\n    const optional = options?.optional ?? false;\n\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available`);\n      }\n    }\n  }\n\n  getComponent() {\n    return this.component;\n  }\n\n  setComponent(component) {\n    if (component.name !== this.name) {\n      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n    }\n\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n\n    this.component = component; // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n\n    if (!this.shouldAutoInitialize()) {\n      return;\n    } // if the service is eager, initialize the default instance\n\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({\n          instanceIdentifier: DEFAULT_ENTRY_NAME\n        });\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    } // Create service instances for the pending promises and resolve them\n    // NOTE: if this.multipleInstances is false, only the default instance will be created\n    // and all promises with resolve with it regardless of the identifier.\n\n\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      try {\n        // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n        const instance = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n        instanceDeferred.resolve(instance);\n      } catch (e) {// when the instance factory throws an exception, it should not cause\n        // a fatal error. We just leave the promise unresolved.\n      }\n    }\n  }\n\n  clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  } // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  delete() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const services = Array.from(_this.instances.values());\n      yield Promise.all([...services.filter(service => 'INTERNAL' in service) // legacy services\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .map(service => service.INTERNAL.delete()), ...services.filter(service => '_delete' in service) // modularized services\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .map(service => service._delete())]);\n    })();\n  }\n\n  isComponentSet() {\n    return this.component != null;\n  }\n\n  isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instances.has(identifier);\n  }\n\n  getOptions(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instancesOptions.get(identifier) || {};\n  }\n\n  initialize(opts = {}) {\n    const {\n      options = {}\n    } = opts;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n    }\n\n    if (!this.isComponentSet()) {\n      throw Error(`Component ${this.name} has not been registered yet`);\n    }\n\n    const instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options\n    }); // resolve any pending promise waiting for the service instance\n\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      if (normalizedIdentifier === normalizedDeferredIdentifier) {\n        instanceDeferred.resolve(instance);\n      }\n    }\n\n    return instance;\n  }\n  /**\n   *\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n   *\n   * @param identifier An optional instance identifier\n   * @returns a function to unregister the callback\n   */\n\n\n  onInit(callback, identifier) {\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    const existingCallbacks = this.onInitCallbacks.get(normalizedIdentifier) ?? new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    const existingInstance = this.instances.get(normalizedIdentifier);\n\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n\n    return () => {\n      existingCallbacks.delete(callback);\n    };\n  }\n  /**\n   * Invoke onInit callbacks synchronously\n   * @param instance the service instance`\n   */\n\n\n  invokeOnInitCallbacks(instance, identifier) {\n    const callbacks = this.onInitCallbacks.get(identifier);\n\n    if (!callbacks) {\n      return;\n    }\n\n    for (const callback of callbacks) {\n      try {\n        callback(instance, identifier);\n      } catch {// ignore errors in the onInit callback\n      }\n    }\n  }\n\n  getOrInitializeService({\n    instanceIdentifier,\n    options = {}\n  }) {\n    let instance = this.instances.get(instanceIdentifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      /**\n       * Invoke onInit listeners.\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\n       * while onInit listeners are registered by consumers of the provider.\n       */\n\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      /**\n       * Order is important\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n       * makes `isInitialized()` return true.\n       */\n\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch {// ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n\n    return instance || null;\n  }\n\n  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  }\n\n  shouldAutoInitialize() {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\"\n    /* InstantiationMode.EXPLICIT */\n    ;\n  }\n\n} // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* InstantiationMode.EAGER */\n  ;\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\n\n\nclass ComponentContainer {\n  constructor(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\n   *\n   * @param component Component being added\n   * @param overwrite When a component with the same name has already been registered,\n   * if overwrite is true: overwrite the existing component with the new component and create a new\n   * provider with the new component. It can be useful in tests where you want to use different mocks\n   * for different tests.\n   * if overwrite is false: throw an exception\n   */\n\n\n  addComponent(component) {\n    const provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n    }\n\n    provider.setComponent(component);\n  }\n\n  addOrOverwriteComponent(component) {\n    const provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  }\n  /**\n   * getProvider provides a type safe interface where it can only be called with a field name\n   * present in NameServiceMapping interface.\n   *\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\n   * themselves.\n   */\n\n\n  getProvider(name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    const provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  }\n\n  getProviders() {\n    return Array.from(this.providers.values());\n  }\n\n}\n\nexport { Component, ComponentContainer, Provider };","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@firebase/component/dist/esm/index.esm.js"],"names":["Deferred","Component","constructor","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","onInstanceCreated","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","setInstanceCreatedCallback","callback","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","promise","getImmediate","options","optional","Error","getComponent","setComponent","isComponentEager","instanceDeferred","entries","clearInstance","delete","services","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","isComponentSet","getOptions","initialize","opts","normalizedDeferredIdentifier","onInit","existingCallbacks","Set","add","existingInstance","invokeOnInitCallbacks","callbacks","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"mappings":"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","sourcesContent":["import { Deferred } from '@firebase/util';\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options?.identifier);\n        const optional = options?.optional ?? false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = this.onInitCallbacks.get(normalizedIdentifier) ??\n            new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\nexport { Component, ComponentContainer, Provider };\n"]},"metadata":{},"sourceType":"module"}