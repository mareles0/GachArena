{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { collection, doc, getDocs, addDoc, updateDoc, deleteDoc, query, where, Timestamp } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nexport let FriendService = /*#__PURE__*/(() => {\n  class FriendService {\n    constructor() {}\n\n    sendFriendRequest(fromUserId, toUserId, fromUserName, toUserName, fromUserPhoto) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          // Verificar se já existe uma solicitação pendente\n          const q = query(collection(db, 'friends'), where('userId', '==', fromUserId), where('friendId', '==', toUserId), where('status', '==', 'PENDING'));\n          const existing = yield getDocs(q);\n\n          if (!existing.empty) {\n            throw new Error('Já existe uma solicitação pendente');\n          } // Verificar se já são amigos\n\n\n          const friendshipCheck = yield _this.areFriends(fromUserId, toUserId);\n\n          if (friendshipCheck) {\n            throw new Error('Vocês já são amigos');\n          } // construir payload sem campos undefined (Firestore não aceita `undefined`)\n\n\n          const payload = {\n            userId: fromUserId,\n            friendId: toUserId,\n            friendUsername: toUserName,\n            status: 'PENDING',\n            createdAt: Timestamp.now()\n          };\n\n          if (typeof fromUserPhoto !== 'undefined' && fromUserPhoto !== null && fromUserPhoto !== '') {\n            payload.friendPhotoURL = fromUserPhoto;\n          }\n\n          const docRef = yield addDoc(collection(db, 'friends'), payload);\n          return docRef.id;\n        } catch (error) {\n          console.error('Erro ao enviar solicitação de amizade:', error);\n          throw error;\n        }\n      })();\n    }\n\n    getPendingRequests(userId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const q = query(collection(db, 'friends'), where('friendId', '==', userId), where('status', '==', 'PENDING'));\n          const querySnapshot = yield getDocs(q);\n          return querySnapshot.docs.map(doc => Object.assign({\n            id: doc.id\n          }, doc.data()));\n        } catch (error) {\n          console.error('Erro ao buscar solicitações pendentes:', error);\n          return [];\n        }\n      })();\n    }\n\n    acceptFriendRequest(requestId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'friends', requestId);\n          yield updateDoc(docRef, {\n            status: 'ACCEPTED'\n          });\n        } catch (error) {\n          console.error('Erro ao aceitar solicitação:', error);\n          throw error;\n        }\n      })();\n    }\n\n    rejectFriendRequest(requestId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'friends', requestId);\n          yield updateDoc(docRef, {\n            status: 'REJECTED'\n          });\n        } catch (error) {\n          console.error('Erro ao rejeitar solicitação:', error);\n          throw error;\n        }\n      })();\n    }\n\n    getFriends(userId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const q = query(collection(db, 'friends'), where('status', '==', 'ACCEPTED'));\n          const querySnapshot = yield getDocs(q);\n          const allFriends = querySnapshot.docs.map(doc => Object.assign({\n            id: doc.id\n          }, doc.data())); // Filtrar amigos do usuário (pode estar em userId ou friendId)\n\n          return allFriends.filter(friend => friend.userId === userId || friend.friendId === userId);\n        } catch (error) {\n          console.error('Erro ao buscar amigos:', error);\n          return [];\n        }\n      })();\n    }\n\n    removeFriend(friendshipId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'friends', friendshipId);\n          yield deleteDoc(docRef);\n        } catch (error) {\n          console.error('Erro ao remover amigo:', error);\n          throw error;\n        }\n      })();\n    }\n\n    areFriends(user1Id, user2Id) {\n      return _asyncToGenerator(function* () {\n        try {\n          const q = query(collection(db, 'friends'), where('status', '==', 'ACCEPTED'));\n          const querySnapshot = yield getDocs(q);\n          const friendships = querySnapshot.docs.map(doc => doc.data());\n          return friendships.some(f => f.userId === user1Id && f.friendId === user2Id || f.userId === user2Id && f.friendId === user1Id);\n        } catch (error) {\n          console.error('Erro ao verificar amizade:', error);\n          return false;\n        }\n      })();\n    }\n\n    searchUsers(searchTerm, currentUserId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const usersSnapshot = yield getDocs(collection(db, 'users'));\n          const users = usersSnapshot.docs.map(doc => Object.assign({\n            id: doc.id\n          }, doc.data())); // Filtrar usuários que correspondem à busca (exceto o próprio usuário)\n\n          return users.filter(user => user.id !== currentUserId && user.userType === 'PLAYER' && (user.username.toLowerCase().includes(searchTerm.toLowerCase()) || user.email.toLowerCase().includes(searchTerm.toLowerCase())));\n        } catch (error) {\n          console.error('Erro ao buscar usuários:', error);\n          return [];\n        }\n      })();\n    }\n\n  }\n\n  FriendService.ɵfac = function FriendService_Factory(t) {\n    return new (t || FriendService)();\n  };\n\n  FriendService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FriendService,\n    factory: FriendService.ɵfac,\n    providedIn: 'root'\n  });\n  return FriendService;\n})();","map":null,"metadata":{},"sourceType":"module"}