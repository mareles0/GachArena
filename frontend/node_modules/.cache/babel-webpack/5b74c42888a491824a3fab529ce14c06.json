{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { collection, doc, getDoc, getDocs, query, where, updateDoc, deleteDoc, addDoc, runTransaction, writeBatch } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nexport let TradeService = /*#__PURE__*/(() => {\n  class TradeService {\n    constructor() {}\n\n    createTrade(trade) {\n      return _asyncToGenerator(function* () {\n        const tradeData = Object.assign(Object.assign({}, trade), {\n          status: 'PENDING',\n          createdAt: new Date(),\n          updatedAt: new Date()\n        });\n        const docRef = yield addDoc(collection(db, 'trades'), tradeData);\n        return docRef.id;\n      })();\n    }\n\n    getTradeById(tradeId) {\n      return _asyncToGenerator(function* () {\n        const docRef = doc(db, 'trades', tradeId);\n        const docSnap = yield getDoc(docRef);\n\n        if (docSnap.exists()) {\n          return Object.assign({\n            id: docSnap.id\n          }, docSnap.data());\n        }\n\n        return null;\n      })();\n    }\n\n    getUserSentTrades(userId) {\n      return _asyncToGenerator(function* () {\n        const q = query(collection(db, 'trades'), where('fromUserId', '==', userId));\n        const querySnapshot = yield getDocs(q);\n        return querySnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data()));\n      })();\n    }\n\n    getUserReceivedTrades(userId) {\n      return _asyncToGenerator(function* () {\n        const q = query(collection(db, 'trades'), where('toUserId', '==', userId));\n        const querySnapshot = yield getDocs(q);\n        return querySnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data()));\n      })();\n    }\n\n    acceptTrade(tradeId) {\n      return _asyncToGenerator(function* () {\n        // Ao aceitar, validar posses e trocar ownership dos userItems de forma atômica\n        const tradeRef = doc(db, 'trades', tradeId);\n        yield runTransaction(db, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (tx) {\n            const tradeSnap = yield tx.get(tradeRef);\n            if (!tradeSnap.exists()) throw new Error('Trade não encontrado');\n            const trade = tradeSnap.data();\n            if (trade.status !== 'PENDING') throw new Error('Trade já processado');\n            const fromUserId = trade.fromUserId;\n            const toUserId = trade.toUserId; // Ler todos os userItems envolvidos\n\n            const allUserItemIds = [...(trade.offeredUserItemIds || []), ...(trade.requestedUserItemIds || [])];\n            const userItemSnaps = yield Promise.all(allUserItemIds.map(id => getDoc(doc(db, 'userItems', id)))); // Validar propriedade\n\n            for (const id of trade.offeredUserItemIds) {\n              const snap = userItemSnaps.find(s => s && s.id === id);\n              if (!snap || !snap.exists()) throw new Error('Item oferecido não encontrado: ' + id);\n              const data = snap.data();\n              if (data.userId !== fromUserId) throw new Error('O usuário não possui o item oferecido: ' + id);\n            }\n\n            for (const id of trade.requestedUserItemIds) {\n              const snap = userItemSnaps.find(s => s && s.id === id);\n              if (!snap || !snap.exists()) throw new Error('Item solicitado não encontrado: ' + id);\n              const data = snap.data();\n              if (data.userId !== toUserId) throw new Error('O usuário não possui o item solicitado: ' + id);\n            } // Coletar userItemIds transferidos para limpar showcasedCards\n\n\n            const transferredUserItemIds = new Set([...trade.offeredUserItemIds, ...trade.requestedUserItemIds]);\n            console.log('acceptTrade - transferredUserItemIds:', Array.from(transferredUserItemIds)); // Realizar transferências (simples: atualizar userId ou ajustar quantities)\n            // Usar batch para operações de escrita\n\n            const batch = writeBatch(db); // Transferir oferecidos -> toUserId\n\n            for (const id of trade.offeredUserItemIds) {\n              const ref = doc(db, 'userItems', id);\n              const snap = userItemSnaps.find(s => s && s.id === id);\n              const data = snap.data();\n\n              if (data.quantity && data.quantity > 1) {\n                // decrementar quantidade no documento origem\n                batch.update(ref, {\n                  quantity: data.quantity - 1\n                }); // incrementar/crear doc destino (toUserId_itemId)\n\n                const destId = `${toUserId}_${data.itemId}`;\n                const destRef = doc(db, 'userItems', destId);\n                const destSnap = yield getDoc(destRef);\n\n                if (destSnap.exists()) {\n                  batch.update(destRef, {\n                    quantity: destSnap.data().quantity + 1\n                  });\n                } else {\n                  batch.set(destRef, {\n                    userId: toUserId,\n                    itemId: data.itemId,\n                    item: data.item,\n                    obtainedAt: new Date(),\n                    quantity: 1\n                  });\n                }\n              } else {\n                // quantidade == 1 -> mudar dono (atualizar userId)\n                batch.update(ref, {\n                  userId: toUserId,\n                  obtainedAt: new Date()\n                });\n              }\n            } // Transferir solicitados -> fromUserId\n\n\n            for (const id of trade.requestedUserItemIds) {\n              const ref = doc(db, 'userItems', id);\n              const snap = userItemSnaps.find(s => s && s.id === id);\n              const data = snap.data();\n\n              if (data.quantity && data.quantity > 1) {\n                batch.update(ref, {\n                  quantity: data.quantity - 1\n                });\n                const destId = `${fromUserId}_${data.itemId}`;\n                const destRef = doc(db, 'userItems', destId);\n                const destSnap = yield getDoc(destRef);\n\n                if (destSnap.exists()) {\n                  batch.update(destRef, {\n                    quantity: destSnap.data().quantity + 1\n                  });\n                } else {\n                  batch.set(destRef, {\n                    userId: fromUserId,\n                    itemId: data.itemId,\n                    item: data.item,\n                    obtainedAt: new Date(),\n                    quantity: 1\n                  });\n                }\n              } else {\n                batch.update(ref, {\n                  userId: fromUserId,\n                  obtainedAt: new Date()\n                });\n              }\n            } // Limpar showcasedCards dos usuários envolvidos\n\n\n            const fromUserRef = doc(db, 'users', fromUserId);\n            const toUserRef = doc(db, 'users', toUserId);\n            const fromUserSnap = yield tx.get(fromUserRef);\n            const toUserSnap = yield tx.get(toUserRef);\n\n            if (fromUserSnap.exists()) {\n              const fromUserData = fromUserSnap.data();\n              const currentShowcased = fromUserData.showcasedCards || [];\n              const filteredShowcased = currentShowcased.filter(userItemId => !transferredUserItemIds.has(userItemId));\n              console.log('acceptTrade - fromUser showcasedCards:', {\n                before: currentShowcased,\n                after: filteredShowcased\n              });\n\n              if (filteredShowcased.length !== currentShowcased.length) {\n                batch.update(fromUserRef, {\n                  showcasedCards: filteredShowcased\n                });\n              }\n            }\n\n            if (toUserSnap.exists()) {\n              const toUserData = toUserSnap.data();\n              const currentShowcased = toUserData.showcasedCards || [];\n              const filteredShowcased = currentShowcased.filter(userItemId => !transferredUserItemIds.has(userItemId));\n              console.log('acceptTrade - toUser showcasedCards:', {\n                before: currentShowcased,\n                after: filteredShowcased\n              });\n\n              if (filteredShowcased.length !== currentShowcased.length) {\n                batch.update(toUserRef, {\n                  showcasedCards: filteredShowcased\n                });\n              }\n            } // Atualizar trade status\n\n\n            batch.update(tradeRef, {\n              status: 'ACCEPTED',\n              updatedAt: new Date()\n            }); // Commit batch\n\n            yield batch.commit();\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n\n    rejectTrade(tradeId) {\n      return _asyncToGenerator(function* () {\n        const docRef = doc(db, 'trades', tradeId);\n        yield updateDoc(docRef, {\n          status: 'REJECTED',\n          updatedAt: new Date()\n        });\n      })();\n    }\n\n    cancelTrade(tradeId) {\n      return _asyncToGenerator(function* () {\n        const docRef = doc(db, 'trades', tradeId);\n        yield updateDoc(docRef, {\n          status: 'CANCELLED',\n          updatedAt: new Date()\n        });\n      })();\n    }\n\n    deleteTrade(tradeId) {\n      return _asyncToGenerator(function* () {\n        yield deleteDoc(doc(db, 'trades', tradeId));\n      })();\n    }\n\n  }\n\n  TradeService.ɵfac = function TradeService_Factory(t) {\n    return new (t || TradeService)();\n  };\n\n  TradeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TradeService,\n    factory: TradeService.ɵfac,\n    providedIn: 'root'\n  });\n  return TradeService;\n})();","map":null,"metadata":{},"sourceType":"module"}