{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./user.service\";\nexport class ProfileService {\n  constructor(http, userService) {\n    this.http = http;\n    this.userService = userService;\n    this.iconsIndexPath = 'assets/avatares/index.json';\n  } // Lista de ícones disponíveis, organizados por categoria/anime.\n  // O arquivo `assets/avatares/index.json` pode ser:\n  // 1) um array simples de caminhos: [\"assets/...png\", ...]\n  // 2) um objeto por categorias: { \"Naruto\": [\"assets/...png\"], \"OnePiece\": [...] }\n\n\n  listAvailableIconsGrouped() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this.http.get(_this.iconsIndexPath).toPromise();\n        if (!res) return {}; // se for array simples, colocar em 'Geral'\n\n        if (Array.isArray(res)) {\n          return {\n            Geral: res\n          };\n        } // se for objeto, assumir que já está no formato desejado\n\n\n        return res;\n      } catch (error) {\n        console.error('Erro ao listar icons agrupados:', error);\n        return {};\n      }\n    })();\n  } // lista de fundos disponíveis para perfil (assets/backgrounds/index.json)\n\n\n  listAvailableBackgrounds() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this2.http.get('assets/backgrounds/index.json').toPromise();\n        if (!res) return [];\n        let files = [];\n        if (Array.isArray(res)) files = res;else files = Object.keys(res).reduce((acc, k) => acc.concat(res[k] || []), []);\n        return files.map(f => ({\n          src: f,\n          type: /\\.(webm|mp4)$/i.test(f) ? 'video' : /\\.(gif)$/i.test(f) ? 'gif' : 'image'\n        }));\n      } catch (error) {\n        console.error('Erro ao listar backgrounds:', error);\n        return [];\n      }\n    })();\n  } // Busca perfil (merge com doc de usuário)\n\n\n  getProfile(userId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const user = yield _this3.userService.getUserById(userId);\n        if (!user) return null; // Sempre usar o `username` do documento de usuário como nome de exibição\n\n        const profile = {\n          displayName: user.username,\n          profileIcon: user.profileIcon || user.photoURL,\n          profileBackground: user.profileBackground || '',\n          description: user.description || '',\n          showcasedCards: user.showcasedCards || []\n        };\n        return profile;\n      } catch (error) {\n        console.error('Erro ao obter profile:', error);\n        return null;\n      }\n    })();\n  }\n\n  updateProfile(userId, profile) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // Construir payload apenas com campos definidos (Firestore rejeita `undefined`)\n        const payload = {}; // displayName não é mais usado - username é fixo\n        // if (typeof profile.displayName !== 'undefined') payload.displayName = profile.displayName;\n\n        if (typeof profile.profileIcon !== 'undefined') payload.profileIcon = profile.profileIcon;\n        if (typeof profile.profileBackground !== 'undefined') payload.profileBackground = profile.profileBackground;\n        if (typeof profile.description !== 'undefined') payload.description = profile.description;\n        if (typeof profile.showcasedCards !== 'undefined') payload.showcasedCards = profile.showcasedCards; // Se não há nada para atualizar, sair sem chamar o Firestore\n\n        if (Object.keys(payload).length === 0) return;\n        yield _this4.userService.updateUser(userId, payload);\n      } catch (error) {\n        console.error('Erro ao atualizar profile:', error);\n        throw error;\n      }\n    })();\n  }\n\n}\n\nProfileService.ɵfac = function ProfileService_Factory(t) {\n  return new (t || ProfileService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService));\n};\n\nProfileService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ProfileService,\n  factory: ProfileService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/profile.service.ts"],"names":["i0","i1","i2","ProfileService","constructor","http","userService","iconsIndexPath","listAvailableIconsGrouped","res","get","toPromise","Array","isArray","Geral","error","console","listAvailableBackgrounds","files","Object","keys","reduce","acc","k","concat","map","f","src","type","test","getProfile","userId","user","getUserById","profile","displayName","username","profileIcon","photoURL","profileBackground","description","showcasedCards","updateProfile","payload","length","updateUser","ɵfac","ProfileService_Factory","t","ɵɵinject","HttpClient","UserService","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import * as i0 from \"@angular/core\";\r\nimport * as i1 from \"@angular/common/http\";\r\nimport * as i2 from \"./user.service\";\r\nexport class ProfileService {\r\n    constructor(http, userService) {\r\n        this.http = http;\r\n        this.userService = userService;\r\n        this.iconsIndexPath = 'assets/avatares/index.json';\r\n    }\r\n    // Lista de ícones disponíveis, organizados por categoria/anime.\r\n    // O arquivo `assets/avatares/index.json` pode ser:\r\n    // 1) um array simples de caminhos: [\"assets/...png\", ...]\r\n    // 2) um objeto por categorias: { \"Naruto\": [\"assets/...png\"], \"OnePiece\": [...] }\r\n    async listAvailableIconsGrouped() {\r\n        try {\r\n            const res = await this.http.get(this.iconsIndexPath).toPromise();\r\n            if (!res)\r\n                return {};\r\n            // se for array simples, colocar em 'Geral'\r\n            if (Array.isArray(res)) {\r\n                return { Geral: res };\r\n            }\r\n            // se for objeto, assumir que já está no formato desejado\r\n            return res;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao listar icons agrupados:', error);\r\n            return {};\r\n        }\r\n    }\r\n    // lista de fundos disponíveis para perfil (assets/backgrounds/index.json)\r\n    async listAvailableBackgrounds() {\r\n        try {\r\n            const res = await this.http.get('assets/backgrounds/index.json').toPromise();\r\n            if (!res)\r\n                return [];\r\n            let files = [];\r\n            if (Array.isArray(res))\r\n                files = res;\r\n            else\r\n                files = Object.keys(res).reduce((acc, k) => acc.concat(res[k] || []), []);\r\n            return files.map(f => ({ src: f, type: /\\.(webm|mp4)$/i.test(f) ? 'video' : (/\\.(gif)$/i.test(f) ? 'gif' : 'image') }));\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao listar backgrounds:', error);\r\n            return [];\r\n        }\r\n    }\r\n    // Busca perfil (merge com doc de usuário)\r\n    async getProfile(userId) {\r\n        try {\r\n            const user = await this.userService.getUserById(userId);\r\n            if (!user)\r\n                return null;\r\n            // Sempre usar o `username` do documento de usuário como nome de exibição\r\n            const profile = {\r\n                displayName: user.username,\r\n                profileIcon: user.profileIcon || user.photoURL,\r\n                profileBackground: user.profileBackground || '',\r\n                description: user.description || '',\r\n                showcasedCards: user.showcasedCards || []\r\n            };\r\n            return profile;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao obter profile:', error);\r\n            return null;\r\n        }\r\n    }\r\n    async updateProfile(userId, profile) {\r\n        try {\r\n            // Construir payload apenas com campos definidos (Firestore rejeita `undefined`)\r\n            const payload = {};\r\n            // displayName não é mais usado - username é fixo\r\n            // if (typeof profile.displayName !== 'undefined') payload.displayName = profile.displayName;\r\n            if (typeof profile.profileIcon !== 'undefined')\r\n                payload.profileIcon = profile.profileIcon;\r\n            if (typeof profile.profileBackground !== 'undefined')\r\n                payload.profileBackground = profile.profileBackground;\r\n            if (typeof profile.description !== 'undefined')\r\n                payload.description = profile.description;\r\n            if (typeof profile.showcasedCards !== 'undefined')\r\n                payload.showcasedCards = profile.showcasedCards;\r\n            // Se não há nada para atualizar, sair sem chamar o Firestore\r\n            if (Object.keys(payload).length === 0)\r\n                return;\r\n            await this.userService.updateUser(userId, payload);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao atualizar profile:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nProfileService.ɵfac = function ProfileService_Factory(t) { return new (t || ProfileService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService)); };\r\nProfileService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ProfileService, factory: ProfileService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}