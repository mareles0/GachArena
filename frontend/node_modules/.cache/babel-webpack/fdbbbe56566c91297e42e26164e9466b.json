{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __rest } from \"tslib\";\nimport { collection, doc, getDoc, getDocs, addDoc, updateDoc, deleteDoc, query, where, Timestamp, runTransaction } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nexport class MissionService {\n  constructor() {} // CRUD Missões\n\n\n  createMission(mission) {\n    return _asyncToGenerator(function* () {\n      try {\n        // Avoid persisting an `id` field inside the document body which\n        // could later overwrite the Firestore doc id when merging.\n        const payload = Object.assign({}, mission);\n        if ('id' in payload) delete payload.id;\n        payload.createdAt = Timestamp.now();\n        const docRef = yield addDoc(collection(db, 'missions'), payload);\n        console.log('Created mission in Firestore:', docRef.id, payload);\n        return docRef.id;\n      } catch (error) {\n        console.error('Erro ao criar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n  getMission(id) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'missions', id);\n        const docSnap = yield getDoc(docRef);\n\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n\n          const _a = data,\n                {\n            id: _id\n          } = _a,\n                rest = __rest(_a, [\"id\"]);\n\n          return Object.assign({\n            id: docSnap.id\n          }, rest);\n        }\n\n        return null;\n      } catch (error) {\n        console.error('Erro ao buscar missão:', error);\n        return null;\n      }\n    })();\n  }\n\n  getAllMissions() {\n    return _asyncToGenerator(function* () {\n      try {\n        const querySnapshot = yield getDocs(collection(db, 'missions'));\n        const docsInfo = querySnapshot.docs.map(d => ({\n          id: d.id\n        }));\n        console.log('Fetched missions doc ids:', docsInfo);\n        return querySnapshot.docs.map(d => {\n          const data = d.data();\n\n          const _a = data,\n                {\n            id: _id\n          } = _a,\n                rest = __rest(_a, [\"id\"]);\n\n          return Object.assign({\n            id: d.id\n          }, rest);\n        });\n      } catch (error) {\n        console.error('Erro ao buscar missões:', error);\n        return [];\n      }\n    })();\n  }\n\n  getActiveMissions() {\n    return _asyncToGenerator(function* () {\n      try {\n        const q = query(collection(db, 'missions'), where('active', '==', true));\n        const querySnapshot = yield getDocs(q);\n        return querySnapshot.docs.map(d => {\n          const data = d.data();\n\n          const _a = data,\n                {\n            id: _id\n          } = _a,\n                rest = __rest(_a, [\"id\"]);\n\n          return Object.assign({\n            id: d.id\n          }, rest);\n        });\n      } catch (error) {\n        console.error('Erro ao buscar missões ativas:', error);\n        return [];\n      }\n    })();\n  }\n\n  updateMission(id, mission) {\n    return _asyncToGenerator(function* () {\n      try {\n        if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\n          console.error('Invalid mission id provided to updateMission:', id);\n          throw new Error('Invalid mission id provided to updateMission');\n        }\n\n        const docRef = doc(db, 'missions', id);\n        yield updateDoc(docRef, mission);\n      } catch (error) {\n        console.error('Erro ao atualizar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n  deleteMission(id) {\n    return _asyncToGenerator(function* () {\n      try {\n        if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\n          console.error('Invalid mission id provided to deleteMission:', id);\n          throw new Error('Invalid mission id provided to deleteMission');\n        }\n\n        const docRef = doc(db, 'missions', id);\n        yield deleteDoc(docRef); // Deletar todas as UserMissions associadas\n\n        const userMissionsQuery = query(collection(db, 'userMissions'), where('missionId', '==', id));\n        const userMissionsSnapshot = yield getDocs(userMissionsQuery);\n        const deletePromises = userMissionsSnapshot.docs.map(doc => deleteDoc(doc.ref));\n        yield Promise.all(deletePromises);\n      } catch (error) {\n        console.error('Erro ao deletar missão:', error);\n        throw error;\n      }\n    })();\n  } // UserMissions\n\n\n  getUserMissions(userId) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const q = query(collection(db, 'userMissions'), where('userId', '==', userId));\n        const querySnapshot = yield getDocs(q);\n        const userMissions = querySnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data())); // Buscar detalhes da missão\n\n        const missionsWithDetails = yield Promise.all(userMissions.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (um) {\n            const mission = yield _this.getMission(um.missionId);\n            return Object.assign(Object.assign({}, um), {\n              mission: mission || undefined\n            });\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n        return missionsWithDetails;\n      } catch (error) {\n        console.error('Erro ao buscar missões do usuário:', error);\n        return [];\n      }\n    })();\n  }\n\n  startMission(userId, missionId) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // Verificar se já existe\n        const q = query(collection(db, 'userMissions'), where('userId', '==', userId), where('missionId', '==', missionId));\n        const existing = yield getDocs(q);\n\n        if (!existing.empty) {\n          return existing.docs[0].id;\n        } // Fetch mission to determine if it should auto-complete (e.g., DAILY with no requirement)\n\n\n        const mission = yield _this2.getMission(missionId);\n        const isAutoComplete = mission && mission.type === 'DAILY' && (mission.autoComplete === true || !mission.requirement || mission.requirement.trim() === '');\n        const payload = {\n          userId,\n          missionId,\n          progress: isAutoComplete ? 100 : 0,\n          completed: isAutoComplete ? true : false,\n          claimed: isAutoComplete ? true : false,\n          claimedDays: [],\n          // nextAvailableAt allows first day to be collectible immediately if not autoComplete\n          nextAvailableAt: isAutoComplete ? undefined : Timestamp.now(),\n          createdAt: Timestamp.now()\n        };\n\n        if (isAutoComplete) {\n          payload.completedAt = Timestamp.now();\n        }\n\n        const docRef = yield addDoc(collection(db, 'userMissions'), payload);\n        return docRef.id;\n      } catch (error) {\n        console.error('Erro ao iniciar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n  claimMission(userMissionId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'userMissions', userMissionId);\n        yield updateDoc(docRef, {\n          claimed: true,\n          claimedAt: Timestamp.now()\n        });\n      } catch (error) {\n        console.error('Erro ao marcar missão como coletada:', error);\n        throw error;\n      }\n    })();\n  }\n\n  claimDaily(userMissionId, day) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const userMissionRef = doc(db, 'userMissions', userMissionId);\n        yield runTransaction(db, /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (tx) {\n            const umSnap = yield tx.get(userMissionRef);\n            if (!umSnap.exists()) throw new Error('UserMission não encontrado');\n            const umData = umSnap.data();\n            const missionId = umData.missionId;\n            const mission = yield _this3.getMission(missionId || '');\n            const totalDays = mission && mission.dailyRewards && mission.dailyRewards.length || 7;\n            const claimedDays = (umData.claimedDays || []).slice();\n            if (claimedDays.includes(day)) throw new Error('Dia já coletado'); // ensure day is the next available unclaimed day (sequential rule)\n\n            const allDays = Array.from({\n              length: totalDays\n            }, (_, i) => i + 1);\n            const nextUnclaimed = allDays.find(d => !claimedDays.includes(d));\n            if (nextUnclaimed !== day) throw new Error('Dia não disponível para coleta'); // check time-based availability\n\n            const nextAvailableTs = umData.nextAvailableAt;\n\n            if (nextAvailableTs) {\n              const nextAvailableMillis = nextAvailableTs.seconds ? nextAvailableTs.seconds * 1000 : nextAvailableTs.toMillis();\n              if (Date.now() < nextAvailableMillis) throw new Error('Dia ainda não disponível');\n            }\n\n            claimedDays.push(day);\n            const progress = Math.round(claimedDays.length / totalDays * 100);\n            const updates = {\n              claimedDays,\n              progress\n            };\n\n            if (claimedDays.length === totalDays) {\n              updates.completed = true;\n              updates.completedAt = Timestamp.now();\n              updates.claimed = true;\n              updates.claimedAt = Timestamp.now();\n              updates.nextAvailableAt = undefined;\n            } else {\n              // set next available to +24h\n              updates.nextAvailableAt = Timestamp.fromMillis(Date.now() + 24 * 60 * 60 * 1000);\n            }\n\n            tx.update(userMissionRef, updates);\n          });\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } catch (error) {\n        console.error('Erro ao coletar dia:', error);\n        throw error;\n      }\n    })();\n  }\n\n  updateProgress(userMissionId, progress) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'userMissions', userMissionId);\n        yield updateDoc(docRef, {\n          progress\n        });\n      } catch (error) {\n        console.error('Erro ao atualizar progresso:', error);\n        throw error;\n      }\n    })();\n  }\n\n  completeMission(userMissionId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'userMissions', userMissionId);\n        yield updateDoc(docRef, {\n          completed: true,\n          completedAt: Timestamp.now()\n        });\n      } catch (error) {\n        console.error('Erro ao completar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n}\n\nMissionService.ɵfac = function MissionService_Factory(t) {\n  return new (t || MissionService)();\n};\n\nMissionService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: MissionService,\n  factory: MissionService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/mission.service.ts"],"names":["__rest","collection","doc","getDoc","getDocs","addDoc","updateDoc","deleteDoc","query","where","Timestamp","runTransaction","db","i0","MissionService","constructor","createMission","mission","payload","Object","assign","id","createdAt","now","docRef","console","log","error","getMission","docSnap","exists","data","_a","_id","rest","getAllMissions","querySnapshot","docsInfo","docs","map","d","getActiveMissions","q","updateMission","trim","includes","Error","deleteMission","userMissionsQuery","userMissionsSnapshot","deletePromises","ref","Promise","all","getUserMissions","userId","userMissions","missionsWithDetails","um","missionId","undefined","startMission","existing","empty","isAutoComplete","type","autoComplete","requirement","progress","completed","claimed","claimedDays","nextAvailableAt","completedAt","claimMission","userMissionId","claimedAt","claimDaily","day","userMissionRef","tx","umSnap","get","umData","totalDays","dailyRewards","length","slice","allDays","Array","from","_","i","nextUnclaimed","find","nextAvailableTs","nextAvailableMillis","seconds","toMillis","Date","push","Math","round","updates","fromMillis","update","updateProgress","completeMission","ɵfac","MissionService_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { __rest } from \"tslib\";\r\nimport { collection, doc, getDoc, getDocs, addDoc, updateDoc, deleteDoc, query, where, Timestamp, runTransaction } from 'firebase/firestore';\r\nimport { db } from '../firebase.config';\r\nimport * as i0 from \"@angular/core\";\r\nexport class MissionService {\r\n    constructor() { }\r\n    // CRUD Missões\r\n    async createMission(mission) {\r\n        try {\r\n            // Avoid persisting an `id` field inside the document body which\r\n            // could later overwrite the Firestore doc id when merging.\r\n            const payload = Object.assign({}, mission);\r\n            if ('id' in payload)\r\n                delete payload.id;\r\n            payload.createdAt = Timestamp.now();\r\n            const docRef = await addDoc(collection(db, 'missions'), payload);\r\n            console.log('Created mission in Firestore:', docRef.id, payload);\r\n            return docRef.id;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao criar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async getMission(id) {\r\n        try {\r\n            const docRef = doc(db, 'missions', id);\r\n            const docSnap = await getDoc(docRef);\r\n            if (docSnap.exists()) {\r\n                const data = docSnap.data();\r\n                const _a = data, { id: _id } = _a, rest = __rest(_a, [\"id\"]);\r\n                return Object.assign({ id: docSnap.id }, rest);\r\n            }\r\n            return null;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missão:', error);\r\n            return null;\r\n        }\r\n    }\r\n    async getAllMissions() {\r\n        try {\r\n            const querySnapshot = await getDocs(collection(db, 'missions'));\r\n            const docsInfo = querySnapshot.docs.map(d => ({ id: d.id }));\r\n            console.log('Fetched missions doc ids:', docsInfo);\r\n            return querySnapshot.docs.map(d => {\r\n                const data = d.data();\r\n                const _a = data, { id: _id } = _a, rest = __rest(_a, [\"id\"]);\r\n                return Object.assign({ id: d.id }, rest);\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missões:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async getActiveMissions() {\r\n        try {\r\n            const q = query(collection(db, 'missions'), where('active', '==', true));\r\n            const querySnapshot = await getDocs(q);\r\n            return querySnapshot.docs.map(d => {\r\n                const data = d.data();\r\n                const _a = data, { id: _id } = _a, rest = __rest(_a, [\"id\"]);\r\n                return Object.assign({ id: d.id }, rest);\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missões ativas:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async updateMission(id, mission) {\r\n        try {\r\n            if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\r\n                console.error('Invalid mission id provided to updateMission:', id);\r\n                throw new Error('Invalid mission id provided to updateMission');\r\n            }\r\n            const docRef = doc(db, 'missions', id);\r\n            await updateDoc(docRef, mission);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao atualizar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async deleteMission(id) {\r\n        try {\r\n            if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\r\n                console.error('Invalid mission id provided to deleteMission:', id);\r\n                throw new Error('Invalid mission id provided to deleteMission');\r\n            }\r\n            const docRef = doc(db, 'missions', id);\r\n            await deleteDoc(docRef);\r\n            // Deletar todas as UserMissions associadas\r\n            const userMissionsQuery = query(collection(db, 'userMissions'), where('missionId', '==', id));\r\n            const userMissionsSnapshot = await getDocs(userMissionsQuery);\r\n            const deletePromises = userMissionsSnapshot.docs.map(doc => deleteDoc(doc.ref));\r\n            await Promise.all(deletePromises);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao deletar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    // UserMissions\r\n    async getUserMissions(userId) {\r\n        try {\r\n            const q = query(collection(db, 'userMissions'), where('userId', '==', userId));\r\n            const querySnapshot = await getDocs(q);\r\n            const userMissions = querySnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n            // Buscar detalhes da missão\r\n            const missionsWithDetails = await Promise.all(userMissions.map(async (um) => {\r\n                const mission = await this.getMission(um.missionId);\r\n                return Object.assign(Object.assign({}, um), { mission: mission || undefined });\r\n            }));\r\n            return missionsWithDetails;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missões do usuário:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async startMission(userId, missionId) {\r\n        try {\r\n            // Verificar se já existe\r\n            const q = query(collection(db, 'userMissions'), where('userId', '==', userId), where('missionId', '==', missionId));\r\n            const existing = await getDocs(q);\r\n            if (!existing.empty) {\r\n                return existing.docs[0].id;\r\n            }\r\n            // Fetch mission to determine if it should auto-complete (e.g., DAILY with no requirement)\r\n            const mission = await this.getMission(missionId);\r\n            const isAutoComplete = mission && mission.type === 'DAILY' && (mission.autoComplete === true || !mission.requirement || mission.requirement.trim() === '');\r\n            const payload = {\r\n                userId,\r\n                missionId,\r\n                progress: isAutoComplete ? 100 : 0,\r\n                completed: isAutoComplete ? true : false,\r\n                claimed: isAutoComplete ? true : false,\r\n                claimedDays: [],\r\n                // nextAvailableAt allows first day to be collectible immediately if not autoComplete\r\n                nextAvailableAt: isAutoComplete ? undefined : Timestamp.now(),\r\n                createdAt: Timestamp.now()\r\n            };\r\n            if (isAutoComplete) {\r\n                payload.completedAt = Timestamp.now();\r\n            }\r\n            const docRef = await addDoc(collection(db, 'userMissions'), payload);\r\n            return docRef.id;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao iniciar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async claimMission(userMissionId) {\r\n        try {\r\n            const docRef = doc(db, 'userMissions', userMissionId);\r\n            await updateDoc(docRef, { claimed: true, claimedAt: Timestamp.now() });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao marcar missão como coletada:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async claimDaily(userMissionId, day) {\r\n        try {\r\n            const userMissionRef = doc(db, 'userMissions', userMissionId);\r\n            await runTransaction(db, async (tx) => {\r\n                const umSnap = await tx.get(userMissionRef);\r\n                if (!umSnap.exists())\r\n                    throw new Error('UserMission não encontrado');\r\n                const umData = umSnap.data();\r\n                const missionId = umData.missionId;\r\n                const mission = await this.getMission(missionId || '');\r\n                const totalDays = (mission && mission.dailyRewards && mission.dailyRewards.length) || 7;\r\n                const claimedDays = (umData.claimedDays || []).slice();\r\n                if (claimedDays.includes(day))\r\n                    throw new Error('Dia já coletado');\r\n                // ensure day is the next available unclaimed day (sequential rule)\r\n                const allDays = Array.from({ length: totalDays }, (_, i) => i + 1);\r\n                const nextUnclaimed = allDays.find(d => !claimedDays.includes(d));\r\n                if (nextUnclaimed !== day)\r\n                    throw new Error('Dia não disponível para coleta');\r\n                // check time-based availability\r\n                const nextAvailableTs = umData.nextAvailableAt;\r\n                if (nextAvailableTs) {\r\n                    const nextAvailableMillis = (nextAvailableTs.seconds ? nextAvailableTs.seconds * 1000 : nextAvailableTs.toMillis());\r\n                    if (Date.now() < nextAvailableMillis)\r\n                        throw new Error('Dia ainda não disponível');\r\n                }\r\n                claimedDays.push(day);\r\n                const progress = Math.round((claimedDays.length / totalDays) * 100);\r\n                const updates = { claimedDays, progress };\r\n                if (claimedDays.length === totalDays) {\r\n                    updates.completed = true;\r\n                    updates.completedAt = Timestamp.now();\r\n                    updates.claimed = true;\r\n                    updates.claimedAt = Timestamp.now();\r\n                    updates.nextAvailableAt = undefined;\r\n                }\r\n                else {\r\n                    // set next available to +24h\r\n                    updates.nextAvailableAt = Timestamp.fromMillis(Date.now() + 24 * 60 * 60 * 1000);\r\n                }\r\n                tx.update(userMissionRef, updates);\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao coletar dia:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async updateProgress(userMissionId, progress) {\r\n        try {\r\n            const docRef = doc(db, 'userMissions', userMissionId);\r\n            await updateDoc(docRef, { progress });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao atualizar progresso:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async completeMission(userMissionId) {\r\n        try {\r\n            const docRef = doc(db, 'userMissions', userMissionId);\r\n            await updateDoc(docRef, {\r\n                completed: true,\r\n                completedAt: Timestamp.now()\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao completar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nMissionService.ɵfac = function MissionService_Factory(t) { return new (t || MissionService)(); };\r\nMissionService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MissionService, factory: MissionService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}