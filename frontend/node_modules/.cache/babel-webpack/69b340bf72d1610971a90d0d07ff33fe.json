{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __rest } from \"tslib\";\nimport { collection, doc, getDoc, getDocs, addDoc, updateDoc, deleteDoc, query, where, Timestamp, runTransaction } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nexport let MissionService = /*#__PURE__*/(() => {\n  class MissionService {\n    constructor() {} // CRUD Missões\n\n\n    createMission(mission) {\n      return _asyncToGenerator(function* () {\n        try {\n          // Avoid persisting an `id` field inside the document body which\n          // could later overwrite the Firestore doc id when merging.\n          const payload = Object.assign({}, mission);\n          if ('id' in payload) delete payload.id;\n          payload.createdAt = Timestamp.now();\n          const docRef = yield addDoc(collection(db, 'missions'), payload);\n          console.log('Created mission in Firestore:', docRef.id, payload);\n          return docRef.id;\n        } catch (error) {\n          console.error('Erro ao criar missão:', error);\n          throw error;\n        }\n      })();\n    }\n\n    getMission(id) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'missions', id);\n          const docSnap = yield getDoc(docRef);\n\n          if (docSnap.exists()) {\n            const data = docSnap.data();\n\n            const _a = data,\n                  {\n              id: _id\n            } = _a,\n                  rest = __rest(_a, [\"id\"]);\n\n            return Object.assign({\n              id: docSnap.id\n            }, rest);\n          }\n\n          return null;\n        } catch (error) {\n          console.error('Erro ao buscar missão:', error);\n          return null;\n        }\n      })();\n    }\n\n    getAllMissions() {\n      return _asyncToGenerator(function* () {\n        try {\n          const querySnapshot = yield getDocs(collection(db, 'missions'));\n          const docsInfo = querySnapshot.docs.map(d => ({\n            id: d.id\n          }));\n          console.log('Fetched missions doc ids:', docsInfo);\n          return querySnapshot.docs.map(d => {\n            const data = d.data();\n\n            const _a = data,\n                  {\n              id: _id\n            } = _a,\n                  rest = __rest(_a, [\"id\"]);\n\n            return Object.assign({\n              id: d.id\n            }, rest);\n          });\n        } catch (error) {\n          console.error('Erro ao buscar missões:', error);\n          return [];\n        }\n      })();\n    }\n\n    getActiveMissions() {\n      return _asyncToGenerator(function* () {\n        try {\n          const q = query(collection(db, 'missions'), where('active', '==', true));\n          const querySnapshot = yield getDocs(q);\n          return querySnapshot.docs.map(d => {\n            const data = d.data();\n\n            const _a = data,\n                  {\n              id: _id\n            } = _a,\n                  rest = __rest(_a, [\"id\"]);\n\n            return Object.assign({\n              id: d.id\n            }, rest);\n          });\n        } catch (error) {\n          console.error('Erro ao buscar missões ativas:', error);\n          return [];\n        }\n      })();\n    }\n\n    updateMission(id, mission) {\n      return _asyncToGenerator(function* () {\n        try {\n          if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\n            console.error('Invalid mission id provided to updateMission:', id);\n            throw new Error('Invalid mission id provided to updateMission');\n          }\n\n          const docRef = doc(db, 'missions', id);\n          yield updateDoc(docRef, mission);\n        } catch (error) {\n          console.error('Erro ao atualizar missão:', error);\n          throw error;\n        }\n      })();\n    }\n\n    deleteMission(id) {\n      return _asyncToGenerator(function* () {\n        try {\n          if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\n            console.error('Invalid mission id provided to deleteMission:', id);\n            throw new Error('Invalid mission id provided to deleteMission');\n          }\n\n          const docRef = doc(db, 'missions', id);\n          yield deleteDoc(docRef); // Deletar todas as UserMissions associadas\n\n          const userMissionsQuery = query(collection(db, 'userMissions'), where('missionId', '==', id));\n          const userMissionsSnapshot = yield getDocs(userMissionsQuery);\n          const deletePromises = userMissionsSnapshot.docs.map(doc => deleteDoc(doc.ref));\n          yield Promise.all(deletePromises);\n        } catch (error) {\n          console.error('Erro ao deletar missão:', error);\n          throw error;\n        }\n      })();\n    } // UserMissions\n\n\n    getUserMissions(userId) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          const q = query(collection(db, 'userMissions'), where('userId', '==', userId));\n          const querySnapshot = yield getDocs(q);\n          const userMissions = querySnapshot.docs.map(doc => Object.assign({\n            id: doc.id\n          }, doc.data())); // Buscar detalhes da missão\n\n          const missionsWithDetails = yield Promise.all(userMissions.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (um) {\n              const mission = yield _this.getMission(um.missionId);\n              return Object.assign(Object.assign({}, um), {\n                mission: mission || undefined\n              });\n            });\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()));\n          return missionsWithDetails;\n        } catch (error) {\n          console.error('Erro ao buscar missões do usuário:', error);\n          return [];\n        }\n      })();\n    }\n\n    startMission(userId, missionId) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          // Verificar se já existe\n          const q = query(collection(db, 'userMissions'), where('userId', '==', userId), where('missionId', '==', missionId));\n          const existing = yield getDocs(q);\n\n          if (!existing.empty) {\n            return existing.docs[0].id;\n          } // Fetch mission to determine if it should auto-complete (e.g., DAILY with no requirement)\n\n\n          const mission = yield _this2.getMission(missionId);\n          const isAutoComplete = mission && mission.type === 'DAILY' && (mission.autoComplete === true || !mission.requirement || mission.requirement.trim() === '');\n          const payload = {\n            userId,\n            missionId,\n            progress: isAutoComplete ? 100 : 0,\n            completed: isAutoComplete ? true : false,\n            claimed: isAutoComplete ? true : false,\n            claimedDays: [],\n            // nextAvailableAt allows first day to be collectible immediately if not autoComplete\n            nextAvailableAt: isAutoComplete ? undefined : Timestamp.now(),\n            createdAt: Timestamp.now()\n          };\n\n          if (isAutoComplete) {\n            payload.completedAt = Timestamp.now();\n          }\n\n          const docRef = yield addDoc(collection(db, 'userMissions'), payload);\n          return docRef.id;\n        } catch (error) {\n          console.error('Erro ao iniciar missão:', error);\n          throw error;\n        }\n      })();\n    }\n\n    claimMission(userMissionId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'userMissions', userMissionId);\n          yield updateDoc(docRef, {\n            claimed: true,\n            claimedAt: Timestamp.now()\n          });\n        } catch (error) {\n          console.error('Erro ao marcar missão como coletada:', error);\n          throw error;\n        }\n      })();\n    }\n\n    claimDaily(userMissionId, day) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          const userMissionRef = doc(db, 'userMissions', userMissionId);\n          yield runTransaction(db, /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (tx) {\n              const umSnap = yield tx.get(userMissionRef);\n              if (!umSnap.exists()) throw new Error('UserMission não encontrado');\n              const umData = umSnap.data();\n              const missionId = umData.missionId;\n              const mission = yield _this3.getMission(missionId || '');\n              const totalDays = mission && mission.dailyRewards && mission.dailyRewards.length || 7;\n              const claimedDays = (umData.claimedDays || []).slice();\n              if (claimedDays.includes(day)) throw new Error('Dia já coletado'); // ensure day is the next available unclaimed day (sequential rule)\n\n              const allDays = Array.from({\n                length: totalDays\n              }, (_, i) => i + 1);\n              const nextUnclaimed = allDays.find(d => !claimedDays.includes(d));\n              if (nextUnclaimed !== day) throw new Error('Dia não disponível para coleta'); // check time-based availability\n\n              const nextAvailableTs = umData.nextAvailableAt;\n\n              if (nextAvailableTs) {\n                const nextAvailableMillis = nextAvailableTs.seconds ? nextAvailableTs.seconds * 1000 : nextAvailableTs.toMillis();\n                if (Date.now() < nextAvailableMillis) throw new Error('Dia ainda não disponível');\n              }\n\n              claimedDays.push(day);\n              const progress = Math.round(claimedDays.length / totalDays * 100);\n              const updates = {\n                claimedDays,\n                progress\n              };\n\n              if (claimedDays.length === totalDays) {\n                updates.completed = true;\n                updates.completedAt = Timestamp.now();\n                updates.claimed = true;\n                updates.claimedAt = Timestamp.now();\n                updates.nextAvailableAt = undefined;\n              } else {\n                // set next available to +24h\n                updates.nextAvailableAt = Timestamp.fromMillis(Date.now() + 24 * 60 * 60 * 1000);\n              }\n\n              tx.update(userMissionRef, updates);\n            });\n\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }());\n        } catch (error) {\n          console.error('Erro ao coletar dia:', error);\n          throw error;\n        }\n      })();\n    }\n\n    updateProgress(userMissionId, progress) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'userMissions', userMissionId);\n          yield updateDoc(docRef, {\n            progress\n          });\n        } catch (error) {\n          console.error('Erro ao atualizar progresso:', error);\n          throw error;\n        }\n      })();\n    }\n\n    completeMission(userMissionId) {\n      return _asyncToGenerator(function* () {\n        try {\n          const docRef = doc(db, 'userMissions', userMissionId);\n          yield updateDoc(docRef, {\n            completed: true,\n            completedAt: Timestamp.now()\n          });\n        } catch (error) {\n          console.error('Erro ao completar missão:', error);\n          throw error;\n        }\n      })();\n    }\n\n  }\n\n  MissionService.ɵfac = function MissionService_Factory(t) {\n    return new (t || MissionService)();\n  };\n\n  MissionService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MissionService,\n    factory: MissionService.ɵfac,\n    providedIn: 'root'\n  });\n  return MissionService;\n})();","map":null,"metadata":{},"sourceType":"module"}