{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { environment } from '../../environments/environment';\nimport { getFirestore, collection, doc, setDoc, getDoc, getDocs, deleteDoc, updateDoc } from 'firebase/firestore';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class ItemService {\n  constructor(http) {\n    this.http = http;\n    this.db = getFirestore();\n  }\n\n  createItem(item) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this.http.post(`${environment.backendUrl}/items`, item).toPromise();\n      return result.id;\n    })();\n  }\n\n  getAllItems() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this2.http.get(`${environment.backendUrl}/items`).toPromise();\n    })();\n  }\n\n  getItemsByBox(boxId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this3.http.get(`${environment.backendUrl}/items/by-box/${boxId}`).toPromise();\n    })();\n  }\n\n  getItemById(itemId) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield _this4.http.get(`${environment.backendUrl}/items/${itemId}`).toPromise();\n      return data ? Object.assign({\n        id: itemId\n      }, data) : null;\n    })();\n  }\n\n  updateItem(itemId, data) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.http.put(`${environment.backendUrl}/items/${itemId}`, data).toPromise();\n    })();\n  } // Função auxiliar para calcular pontos baseado na raridade e rarityLevel\n\n\n  calculateItemPoints(rarity, rarityLevel) {\n    const rarityPoints = {\n      'COMUM': 10,\n      'RARO': 25,\n      'EPICO': 50,\n      'LENDARIO': 100,\n      'MITICO': 200\n    };\n    let points = rarityPoints[rarity] || 10; // Aplicar multiplicador baseado no rarityLevel se existir\n\n    if (rarityLevel && typeof rarityLevel === 'number') {\n      const rarityMultiplier = 1 + (1000 - rarityLevel) / 1000;\n      points = Math.round(points * rarityMultiplier);\n    }\n\n    return points;\n  }\n\n  migrateItemsWithoutPoints() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* (forceRecalculate = false) {\n      // Busca todos os documentos diretamente do Firestore para verificar campos brutos\n      const querySnapshot = yield getDocs(collection(_this6.db, 'items'));\n      const itemsToUpdate = [];\n      const allItems = [];\n      const mode = forceRecalculate ? '(MODO FORÇADO - RECALCULAR TODOS)' : '';\n      console.log(`Verificando todos os itens no banco... ${mode}`);\n      querySnapshot.forEach(doc => {\n        const data = doc.data();\n        allItems.push({\n          id: doc.id,\n          name: data.name,\n          rarity: data.rarity,\n          rarityLevel: data.rarityLevel,\n          points: data.points,\n          hasPointsField: data.hasOwnProperty('points')\n        }); // Se for modo forçado, recalcular todos os itens\n\n        if (forceRecalculate) {\n          itemsToUpdate.push(Object.assign({\n            id: doc.id\n          }, data));\n        } else {\n          // Modo normal: só itens sem pontos válidos\n          const needsMigration = !data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0;\n\n          if (needsMigration) {\n            itemsToUpdate.push(Object.assign({\n              id: doc.id\n            }, data));\n          }\n        }\n      });\n      console.log('Todos os itens encontrados:', allItems);\n      console.log(`Encontrados ${itemsToUpdate.length} itens para atualizar pontos`);\n\n      if (itemsToUpdate.length === 0 && !forceRecalculate) {\n        console.log('Nenhum item precisa de migracao. Verificando se ha itens com points = 0...'); // Verificar especificamente itens com points = 0\n\n        const itemsWithZeroPoints = allItems.filter(item => item.points === 0);\n\n        if (itemsWithZeroPoints.length > 0) {\n          console.log('Encontrados itens com points = 0. Forcando migracao...', itemsWithZeroPoints); // Adicionar itens com points = 0 à lista de atualização\n\n          querySnapshot.forEach(doc => {\n            const data = doc.data();\n\n            if (data.points === 0) {\n              itemsToUpdate.push(Object.assign({\n                id: doc.id\n              }, data));\n            }\n          });\n        } else {\n          console.log('Todos os itens ja tem pontos validos (> 0).');\n          console.log('Dica: Use migrateItemsWithoutPoints(true) para forcar recalculo de todos os pontos.');\n          return;\n        }\n      } // Define pontos baseados na raridade\n\n\n      const rarityPoints = {\n        'COMUM': 10,\n        'RARO': 25,\n        'EPICO': 50,\n        'LENDARIO': 100,\n        'MITICO': 200\n      };\n\n      for (const itemData of itemsToUpdate) {\n        console.log(`Processando item: ${itemData.name}`, {\n          rarity: itemData.rarity,\n          rarityLevel: itemData.rarityLevel,\n          hasRarityLevel: itemData.hasOwnProperty('rarityLevel'),\n          rarityLevelType: typeof itemData.rarityLevel\n        });\n        let points = rarityPoints[itemData.rarity] || 10;\n        console.log(`Pontos base calculados: ${points} para raridade ${itemData.rarity}`); // Aplicar multiplicador baseado no rarityLevel PARA TODOS os itens\n\n        if (itemData.rarityLevel && typeof itemData.rarityLevel === 'number') {\n          const rarityMultiplier = 1 + (1000 - itemData.rarityLevel) / 1000; // 1.0 a 2.0\n\n          const oldPoints = points;\n          points = Math.round(points * rarityMultiplier);\n          console.log(`Aplicando multiplicador: ${oldPoints} x ${rarityMultiplier.toFixed(3)} = ${points} (rarityLevel: ${itemData.rarityLevel})`);\n        } else {\n          console.log(`Sem rarityLevel ou invalido: ${itemData.rarityLevel}`);\n        }\n\n        console.log(`Salvando item ${itemData.name} com ${points} pontos`);\n        yield _this6.updateItem(itemData.id, {\n          points\n        });\n        console.log(`Atualizado item ${itemData.name} com points = ${points}`);\n      }\n\n      console.log('Migração concluída');\n    }).apply(this, arguments);\n  }\n\n  migrateUserItemsPoints() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      console.log('Iniciando migracao de pontos para userItems...'); // Buscar todos os userItems\n\n      const querySnapshot = yield getDocs(collection(_this7.db, 'userItems'));\n      const userItemsToUpdate = [];\n      querySnapshot.forEach(doc => {\n        const data = doc.data(); // Verificar se não tem pontos ou pontos = 0\n\n        if (!data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0) {\n          userItemsToUpdate.push(Object.assign({\n            id: doc.id\n          }, data));\n        }\n      });\n      console.log(`Encontrados ${userItemsToUpdate.length} userItems para atualizar pontos`);\n\n      if (userItemsToUpdate.length === 0) {\n        console.log('Todos os userItems ja tem pontos validos.');\n        return;\n      }\n\n      for (const userItemData of userItemsToUpdate) {\n        // Se não tem item aninhado, buscar pelo itemId\n        let itemRarity = (_a = userItemData.item) === null || _a === void 0 ? void 0 : _a.rarity;\n\n        if (!itemRarity && userItemData.itemId) {\n          const item = yield _this7.getItemById(userItemData.itemId);\n          itemRarity = item === null || item === void 0 ? void 0 : item.rarity;\n        }\n\n        if (!itemRarity) {\n          console.log(`Nao foi possivel determinar raridade para userItem ${userItemData.id}`);\n          continue;\n        }\n\n        const points = _this7.calculateItemPoints(itemRarity, userItemData.rarityLevel);\n\n        console.log(`Migrando userItem ${userItemData.id}: raridade ${itemRarity}, rarityLevel ${userItemData.rarityLevel}, pontos ${points}`);\n        yield updateDoc(doc(_this7.db, 'userItems', userItemData.id), {\n          points\n        });\n        console.log(`Atualizado userItem ${userItemData.id} com points = ${points}`);\n      }\n\n      console.log('Migracao de userItems concluida!');\n    })();\n  }\n\n  deleteItem(itemId) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const docRef = doc(_this8.db, 'items', itemId);\n      yield deleteDoc(docRef);\n    })();\n  }\n\n  deleteAllItems() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      console.log('Deletando todos os itens...');\n      const items = yield _this9.getAllItems();\n      console.log(`Encontrados ${items.length} itens para deletar`);\n\n      for (const item of items) {\n        console.log(`Deletando ${item.name}...`);\n        yield _this9.deleteItem(item.id);\n      }\n\n      console.log('Todos os itens foram deletados!');\n    })();\n  }\n\n  addItemToUser(userId, itemId, rarityLevel) {\n    var _this0 = this;\n\n    return _asyncToGenerator(function* () {\n      const item = yield _this0.getItemById(itemId);\n      if (!item) throw new Error('Item não encontrado'); // Para itens lendários e míticos, garantir rarityLevel único\n\n      let finalRarityLevel;\n\n      if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\n        if (rarityLevel) {\n          // Verificar se o rarityLevel fornecido já existe para este item\n          const exists = yield _this0.checkRarityLevelExists(itemId, rarityLevel, userId);\n\n          if (exists) {\n            throw new Error('Este nível de raridade já existe para este item');\n          }\n\n          finalRarityLevel = rarityLevel;\n        } else {\n          // Gerar rarityLevel único\n          finalRarityLevel = yield _this0.generateUniqueRarityLevel(itemId, userId);\n        }\n      } else {\n        // Para outros itens, usar o rarityLevel fornecido ou gerar aleatório\n        finalRarityLevel = rarityLevel !== null && rarityLevel !== void 0 ? rarityLevel : Math.floor(Math.random() * 1000) + 1;\n      } // Calcular pontos baseado na raridade e rarityLevel\n\n\n      const points = _this0.calculateItemPoints(item.rarity, finalRarityLevel); // Para itens lendários e míticos, cada cópia é tratada como item único\n\n\n      if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\n        // Criar entrada única para cada item lendário/mítico\n        const uniqueId = `${userId}_${itemId}_${Date.now()}_${finalRarityLevel}`;\n        const docRef = doc(_this0.db, 'userItems', uniqueId);\n        const userItemData = {\n          userId,\n          itemId,\n          item,\n          obtainedAt: new Date(),\n          quantity: 1,\n          rarityLevel: finalRarityLevel,\n          points\n        };\n        yield setDoc(docRef, userItemData);\n        return finalRarityLevel;\n      } else {\n        // Para itens comuns, raros e épicos, manter o sistema atual\n        const userItemId = `${userId}_${itemId}`;\n        const docRef = doc(_this0.db, 'userItems', userItemId);\n        const docSnap = yield getDoc(docRef);\n\n        if (docSnap.exists()) {\n          const currentData = docSnap.data();\n          yield updateDoc(docRef, {\n            quantity: currentData['quantity'] + 1,\n            points: Math.max(currentData['points'] || 0, points)\n          });\n          return 0; // No rarity level for common items\n        } else {\n          const userItemData = {\n            userId,\n            itemId,\n            item,\n            obtainedAt: new Date(),\n            quantity: 1,\n            points\n          };\n          yield setDoc(docRef, userItemData);\n          return 0;\n        }\n      }\n    })();\n  }\n\n  getUserItems(userId) {\n    var _this1 = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield _this1.http.get(`${environment.backendUrl}/userItems/user/${userId}`).toPromise();\n      const userItems = yield Promise.all(data.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (ui) {\n          const item = yield _this1.getItemById(ui.itemId);\n          return Object.assign(Object.assign({\n            id: ui.id\n          }, ui), {\n            item\n          });\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return userItems;\n    })();\n  }\n\n  getUserItemById(id) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield _this10.http.get(`${environment.backendUrl}/userItems/${id}`).toPromise();\n\n      if (data) {\n        const item = yield _this10.getItemById(data.itemId);\n        return Object.assign(Object.assign({\n          id\n        }, data), {\n          item\n        });\n      }\n\n      return null;\n    })();\n  }\n\n  getUserRarestItemInBox(userId, boxId) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const userItems = yield _this11.getUserItems(userId);\n      const boxItems = userItems.filter(ui => ui.item.boxId === boxId);\n      if (boxItems.length === 0) return null;\n      boxItems.sort((a, b) => {\n        // Calcular score baseado na raridade e rarityLevel\n        let scoreA = a.item.points || 0;\n        let scoreB = b.item.points || 0; // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\n\n        if ((a.item.rarity === 'LENDARIO' || a.item.rarity === 'MITICO') && a.rarityLevel) {\n          const rarityMultiplierA = 1 + (1000 - a.rarityLevel) / 1000;\n          scoreA = scoreA * rarityMultiplierA;\n        }\n\n        if ((b.item.rarity === 'LENDARIO' || b.item.rarity === 'MITICO') && b.rarityLevel) {\n          const rarityMultiplierB = 1 + (1000 - b.rarityLevel) / 1000;\n          scoreB = scoreB * rarityMultiplierB;\n        }\n\n        return scoreB - scoreA; // Ordenação decrescente\n      });\n      return boxItems[0];\n    })();\n  } // Verificar se um rarityLevel já existe para um item específico\n\n\n  checkRarityLevelExists(itemId, rarityLevel, excludeUserId) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const params = excludeUserId ? `?excludeUserId=${excludeUserId}` : '';\n      const result = yield _this12.http.get(`${environment.backendUrl}/userItems/check-rarity/${itemId}/${rarityLevel}${params}`).toPromise();\n      return result.exists;\n    })();\n  } // Gerar um rarityLevel único para um item\n\n\n  generateUniqueRarityLevel(itemId, userId) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const maxAttempts = 1000; // Evitar loop infinito\n\n      let attempts = 0;\n\n      while (attempts < maxAttempts) {\n        const rarityLevel = Math.floor(Math.random() * 1000) + 1;\n        const exists = yield _this13.checkRarityLevelExists(itemId, rarityLevel, userId);\n\n        if (!exists) {\n          return rarityLevel;\n        }\n\n        attempts++;\n      } // Se não conseguir gerar único após muitas tentativas, usar timestamp como base\n\n\n      const timestampBased = Date.now() % 1000 + 1;\n      return Math.min(timestampBased, 1000);\n    })();\n  }\n\n  drawRandomItem(boxId) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const items = yield _this14.getItemsByBox(boxId);\n      if (items.length === 0) throw new Error('Nenhum item disponível nesta caixa'); // Usar as taxas de drop configuradas para cada item\n\n      const totalDropRate = items.reduce((sum, item) => sum + (item.dropRate || 0), 0);\n\n      if (totalDropRate === 0) {\n        throw new Error('As taxas de drop dos itens não foram configuradas corretamente');\n      } // Gerar número aleatório entre 0 e o total de taxas\n\n\n      const random = Math.random() * totalDropRate; // Selecionar item baseado na taxa de drop\n\n      let currentSum = 0;\n\n      for (const item of items) {\n        currentSum += item.dropRate || 0;\n\n        if (random <= currentSum) {\n          return item;\n        }\n      } // Fallback (não deveria acontecer, mas por segurança)\n\n\n      return items[items.length - 1];\n    })();\n  }\n\n  removeItemFromUser(_x2) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* (userItemId, quantity = 1) {\n      yield _this15.http.post(`${environment.backendUrl}/userItems/${userItemId}/remove`, {\n        quantity\n      }).toPromise();\n    }).apply(this, arguments);\n  }\n\n}\n\nItemService.ɵfac = function ItemService_Factory(t) {\n  return new (t || ItemService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nItemService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ItemService,\n  factory: ItemService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/item.service.ts"],"names":["environment","getFirestore","collection","doc","setDoc","getDoc","getDocs","deleteDoc","updateDoc","i0","i1","ItemService","constructor","http","db","createItem","item","result","post","backendUrl","toPromise","id","getAllItems","get","getItemsByBox","boxId","getItemById","itemId","data","Object","assign","updateItem","put","calculateItemPoints","rarity","rarityLevel","rarityPoints","points","rarityMultiplier","Math","round","migrateItemsWithoutPoints","forceRecalculate","querySnapshot","itemsToUpdate","allItems","mode","console","log","forEach","push","name","hasPointsField","hasOwnProperty","needsMigration","undefined","length","itemsWithZeroPoints","filter","itemData","hasRarityLevel","rarityLevelType","oldPoints","toFixed","migrateUserItemsPoints","_a","userItemsToUpdate","userItemData","itemRarity","deleteItem","docRef","deleteAllItems","items","addItemToUser","userId","Error","finalRarityLevel","exists","checkRarityLevelExists","generateUniqueRarityLevel","floor","random","uniqueId","Date","now","obtainedAt","quantity","userItemId","docSnap","currentData","max","getUserItems","userItems","Promise","all","map","ui","getUserItemById","getUserRarestItemInBox","boxItems","sort","a","b","scoreA","scoreB","rarityMultiplierA","rarityMultiplierB","excludeUserId","params","maxAttempts","attempts","timestampBased","min","drawRandomItem","totalDropRate","reduce","sum","dropRate","currentSum","removeItemFromUser","ɵfac","ItemService_Factory","t","ɵɵinject","HttpClient","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { environment } from '../../environments/environment';\r\nimport { getFirestore, collection, doc, setDoc, getDoc, getDocs, deleteDoc, updateDoc } from 'firebase/firestore';\r\nimport * as i0 from \"@angular/core\";\r\nimport * as i1 from \"@angular/common/http\";\r\nexport class ItemService {\r\n    constructor(http) {\r\n        this.http = http;\r\n        this.db = getFirestore();\r\n    }\r\n    async createItem(item) {\r\n        const result = await this.http.post(`${environment.backendUrl}/items`, item).toPromise();\r\n        return result.id;\r\n    }\r\n    async getAllItems() {\r\n        return await this.http.get(`${environment.backendUrl}/items`).toPromise();\r\n    }\r\n    async getItemsByBox(boxId) {\r\n        return await this.http.get(`${environment.backendUrl}/items/by-box/${boxId}`).toPromise();\r\n    }\r\n    async getItemById(itemId) {\r\n        const data = await this.http.get(`${environment.backendUrl}/items/${itemId}`).toPromise();\r\n        return data ? Object.assign({ id: itemId }, data) : null;\r\n    }\r\n    async updateItem(itemId, data) {\r\n        await this.http.put(`${environment.backendUrl}/items/${itemId}`, data).toPromise();\r\n    }\r\n    // Função auxiliar para calcular pontos baseado na raridade e rarityLevel\r\n    calculateItemPoints(rarity, rarityLevel) {\r\n        const rarityPoints = {\r\n            'COMUM': 10,\r\n            'RARO': 25,\r\n            'EPICO': 50,\r\n            'LENDARIO': 100,\r\n            'MITICO': 200\r\n        };\r\n        let points = rarityPoints[rarity] || 10;\r\n        // Aplicar multiplicador baseado no rarityLevel se existir\r\n        if (rarityLevel && typeof rarityLevel === 'number') {\r\n            const rarityMultiplier = 1 + ((1000 - rarityLevel) / 1000);\r\n            points = Math.round(points * rarityMultiplier);\r\n        }\r\n        return points;\r\n    }\r\n    async migrateItemsWithoutPoints(forceRecalculate = false) {\r\n        // Busca todos os documentos diretamente do Firestore para verificar campos brutos\r\n        const querySnapshot = await getDocs(collection(this.db, 'items'));\r\n        const itemsToUpdate = [];\r\n        const allItems = [];\r\n        const mode = forceRecalculate ? '(MODO FORÇADO - RECALCULAR TODOS)' : '';\r\n        console.log(`Verificando todos os itens no banco... ${mode}`);\r\n        querySnapshot.forEach(doc => {\r\n            const data = doc.data();\r\n            allItems.push({\r\n                id: doc.id,\r\n                name: data.name,\r\n                rarity: data.rarity,\r\n                rarityLevel: data.rarityLevel,\r\n                points: data.points,\r\n                hasPointsField: data.hasOwnProperty('points')\r\n            });\r\n            // Se for modo forçado, recalcular todos os itens\r\n            if (forceRecalculate) {\r\n                itemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n            }\r\n            else {\r\n                // Modo normal: só itens sem pontos válidos\r\n                const needsMigration = !data.hasOwnProperty('points') ||\r\n                    data.points === null ||\r\n                    data.points === undefined ||\r\n                    data.points === 0;\r\n                if (needsMigration) {\r\n                    itemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n                }\r\n            }\r\n        });\r\n        console.log('Todos os itens encontrados:', allItems);\r\n        console.log(`Encontrados ${itemsToUpdate.length} itens para atualizar pontos`);\r\n        if (itemsToUpdate.length === 0 && !forceRecalculate) {\r\n            console.log('Nenhum item precisa de migracao. Verificando se ha itens com points = 0...');\r\n            // Verificar especificamente itens com points = 0\r\n            const itemsWithZeroPoints = allItems.filter(item => item.points === 0);\r\n            if (itemsWithZeroPoints.length > 0) {\r\n                console.log('Encontrados itens com points = 0. Forcando migracao...', itemsWithZeroPoints);\r\n                // Adicionar itens com points = 0 à lista de atualização\r\n                querySnapshot.forEach(doc => {\r\n                    const data = doc.data();\r\n                    if (data.points === 0) {\r\n                        itemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                console.log('Todos os itens ja tem pontos validos (> 0).');\r\n                console.log('Dica: Use migrateItemsWithoutPoints(true) para forcar recalculo de todos os pontos.');\r\n                return;\r\n            }\r\n        }\r\n        // Define pontos baseados na raridade\r\n        const rarityPoints = {\r\n            'COMUM': 10,\r\n            'RARO': 25,\r\n            'EPICO': 50,\r\n            'LENDARIO': 100,\r\n            'MITICO': 200\r\n        };\r\n        for (const itemData of itemsToUpdate) {\r\n            console.log(`Processando item: ${itemData.name}`, {\r\n                rarity: itemData.rarity,\r\n                rarityLevel: itemData.rarityLevel,\r\n                hasRarityLevel: itemData.hasOwnProperty('rarityLevel'),\r\n                rarityLevelType: typeof itemData.rarityLevel\r\n            });\r\n            let points = rarityPoints[itemData.rarity] || 10;\r\n            console.log(`Pontos base calculados: ${points} para raridade ${itemData.rarity}`);\r\n            // Aplicar multiplicador baseado no rarityLevel PARA TODOS os itens\r\n            if (itemData.rarityLevel && typeof itemData.rarityLevel === 'number') {\r\n                const rarityMultiplier = 1 + ((1000 - itemData.rarityLevel) / 1000); // 1.0 a 2.0\r\n                const oldPoints = points;\r\n                points = Math.round(points * rarityMultiplier);\r\n                console.log(`Aplicando multiplicador: ${oldPoints} x ${rarityMultiplier.toFixed(3)} = ${points} (rarityLevel: ${itemData.rarityLevel})`);\r\n            }\r\n            else {\r\n                console.log(`Sem rarityLevel ou invalido: ${itemData.rarityLevel}`);\r\n            }\r\n            console.log(`Salvando item ${itemData.name} com ${points} pontos`);\r\n            await this.updateItem(itemData.id, { points });\r\n            console.log(`Atualizado item ${itemData.name} com points = ${points}`);\r\n        }\r\n        console.log('Migração concluída');\r\n    }\r\n    async migrateUserItemsPoints() {\r\n        var _a;\r\n        console.log('Iniciando migracao de pontos para userItems...');\r\n        // Buscar todos os userItems\r\n        const querySnapshot = await getDocs(collection(this.db, 'userItems'));\r\n        const userItemsToUpdate = [];\r\n        querySnapshot.forEach(doc => {\r\n            const data = doc.data();\r\n            // Verificar se não tem pontos ou pontos = 0\r\n            if (!data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0) {\r\n                userItemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n            }\r\n        });\r\n        console.log(`Encontrados ${userItemsToUpdate.length} userItems para atualizar pontos`);\r\n        if (userItemsToUpdate.length === 0) {\r\n            console.log('Todos os userItems ja tem pontos validos.');\r\n            return;\r\n        }\r\n        for (const userItemData of userItemsToUpdate) {\r\n            // Se não tem item aninhado, buscar pelo itemId\r\n            let itemRarity = (_a = userItemData.item) === null || _a === void 0 ? void 0 : _a.rarity;\r\n            if (!itemRarity && userItemData.itemId) {\r\n                const item = await this.getItemById(userItemData.itemId);\r\n                itemRarity = item === null || item === void 0 ? void 0 : item.rarity;\r\n            }\r\n            if (!itemRarity) {\r\n                console.log(`Nao foi possivel determinar raridade para userItem ${userItemData.id}`);\r\n                continue;\r\n            }\r\n            const points = this.calculateItemPoints(itemRarity, userItemData.rarityLevel);\r\n            console.log(`Migrando userItem ${userItemData.id}: raridade ${itemRarity}, rarityLevel ${userItemData.rarityLevel}, pontos ${points}`);\r\n            await updateDoc(doc(this.db, 'userItems', userItemData.id), { points });\r\n            console.log(`Atualizado userItem ${userItemData.id} com points = ${points}`);\r\n        }\r\n        console.log('Migracao de userItems concluida!');\r\n    }\r\n    async deleteItem(itemId) {\r\n        const docRef = doc(this.db, 'items', itemId);\r\n        await deleteDoc(docRef);\r\n    }\r\n    async deleteAllItems() {\r\n        console.log('Deletando todos os itens...');\r\n        const items = await this.getAllItems();\r\n        console.log(`Encontrados ${items.length} itens para deletar`);\r\n        for (const item of items) {\r\n            console.log(`Deletando ${item.name}...`);\r\n            await this.deleteItem(item.id);\r\n        }\r\n        console.log('Todos os itens foram deletados!');\r\n    }\r\n    async addItemToUser(userId, itemId, rarityLevel) {\r\n        const item = await this.getItemById(itemId);\r\n        if (!item)\r\n            throw new Error('Item não encontrado');\r\n        // Para itens lendários e míticos, garantir rarityLevel único\r\n        let finalRarityLevel;\r\n        if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\r\n            if (rarityLevel) {\r\n                // Verificar se o rarityLevel fornecido já existe para este item\r\n                const exists = await this.checkRarityLevelExists(itemId, rarityLevel, userId);\r\n                if (exists) {\r\n                    throw new Error('Este nível de raridade já existe para este item');\r\n                }\r\n                finalRarityLevel = rarityLevel;\r\n            }\r\n            else {\r\n                // Gerar rarityLevel único\r\n                finalRarityLevel = await this.generateUniqueRarityLevel(itemId, userId);\r\n            }\r\n        }\r\n        else {\r\n            // Para outros itens, usar o rarityLevel fornecido ou gerar aleatório\r\n            finalRarityLevel = rarityLevel !== null && rarityLevel !== void 0 ? rarityLevel : Math.floor(Math.random() * 1000) + 1;\r\n        }\r\n        // Calcular pontos baseado na raridade e rarityLevel\r\n        const points = this.calculateItemPoints(item.rarity, finalRarityLevel);\r\n        // Para itens lendários e míticos, cada cópia é tratada como item único\r\n        if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\r\n            // Criar entrada única para cada item lendário/mítico\r\n            const uniqueId = `${userId}_${itemId}_${Date.now()}_${finalRarityLevel}`;\r\n            const docRef = doc(this.db, 'userItems', uniqueId);\r\n            const userItemData = {\r\n                userId,\r\n                itemId,\r\n                item,\r\n                obtainedAt: new Date(),\r\n                quantity: 1,\r\n                rarityLevel: finalRarityLevel,\r\n                points\r\n            };\r\n            await setDoc(docRef, userItemData);\r\n            return finalRarityLevel;\r\n        }\r\n        else {\r\n            // Para itens comuns, raros e épicos, manter o sistema atual\r\n            const userItemId = `${userId}_${itemId}`;\r\n            const docRef = doc(this.db, 'userItems', userItemId);\r\n            const docSnap = await getDoc(docRef);\r\n            if (docSnap.exists()) {\r\n                const currentData = docSnap.data();\r\n                await updateDoc(docRef, {\r\n                    quantity: currentData['quantity'] + 1,\r\n                    points: Math.max(currentData['points'] || 0, points)\r\n                });\r\n                return 0; // No rarity level for common items\r\n            }\r\n            else {\r\n                const userItemData = {\r\n                    userId,\r\n                    itemId,\r\n                    item,\r\n                    obtainedAt: new Date(),\r\n                    quantity: 1,\r\n                    points\r\n                };\r\n                await setDoc(docRef, userItemData);\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    async getUserItems(userId) {\r\n        const data = await this.http.get(`${environment.backendUrl}/userItems/user/${userId}`).toPromise();\r\n        const userItems = await Promise.all(data.map(async (ui) => {\r\n            const item = await this.getItemById(ui.itemId);\r\n            return Object.assign(Object.assign({ id: ui.id }, ui), { item });\r\n        }));\r\n        return userItems;\r\n    }\r\n    async getUserItemById(id) {\r\n        const data = await this.http.get(`${environment.backendUrl}/userItems/${id}`).toPromise();\r\n        if (data) {\r\n            const item = await this.getItemById(data.itemId);\r\n            return Object.assign(Object.assign({ id }, data), { item });\r\n        }\r\n        return null;\r\n    }\r\n    async getUserRarestItemInBox(userId, boxId) {\r\n        const userItems = await this.getUserItems(userId);\r\n        const boxItems = userItems.filter(ui => ui.item.boxId === boxId);\r\n        if (boxItems.length === 0)\r\n            return null;\r\n        boxItems.sort((a, b) => {\r\n            // Calcular score baseado na raridade e rarityLevel\r\n            let scoreA = a.item.points || 0;\r\n            let scoreB = b.item.points || 0;\r\n            // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\r\n            if ((a.item.rarity === 'LENDARIO' || a.item.rarity === 'MITICO') && a.rarityLevel) {\r\n                const rarityMultiplierA = 1 + ((1000 - a.rarityLevel) / 1000);\r\n                scoreA = scoreA * rarityMultiplierA;\r\n            }\r\n            if ((b.item.rarity === 'LENDARIO' || b.item.rarity === 'MITICO') && b.rarityLevel) {\r\n                const rarityMultiplierB = 1 + ((1000 - b.rarityLevel) / 1000);\r\n                scoreB = scoreB * rarityMultiplierB;\r\n            }\r\n            return scoreB - scoreA; // Ordenação decrescente\r\n        });\r\n        return boxItems[0];\r\n    }\r\n    // Verificar se um rarityLevel já existe para um item específico\r\n    async checkRarityLevelExists(itemId, rarityLevel, excludeUserId) {\r\n        const params = excludeUserId ? `?excludeUserId=${excludeUserId}` : '';\r\n        const result = await this.http.get(`${environment.backendUrl}/userItems/check-rarity/${itemId}/${rarityLevel}${params}`).toPromise();\r\n        return result.exists;\r\n    }\r\n    // Gerar um rarityLevel único para um item\r\n    async generateUniqueRarityLevel(itemId, userId) {\r\n        const maxAttempts = 1000; // Evitar loop infinito\r\n        let attempts = 0;\r\n        while (attempts < maxAttempts) {\r\n            const rarityLevel = Math.floor(Math.random() * 1000) + 1;\r\n            const exists = await this.checkRarityLevelExists(itemId, rarityLevel, userId);\r\n            if (!exists) {\r\n                return rarityLevel;\r\n            }\r\n            attempts++;\r\n        }\r\n        // Se não conseguir gerar único após muitas tentativas, usar timestamp como base\r\n        const timestampBased = (Date.now() % 1000) + 1;\r\n        return Math.min(timestampBased, 1000);\r\n    }\r\n    async drawRandomItem(boxId) {\r\n        const items = await this.getItemsByBox(boxId);\r\n        if (items.length === 0)\r\n            throw new Error('Nenhum item disponível nesta caixa');\r\n        // Usar as taxas de drop configuradas para cada item\r\n        const totalDropRate = items.reduce((sum, item) => sum + (item.dropRate || 0), 0);\r\n        if (totalDropRate === 0) {\r\n            throw new Error('As taxas de drop dos itens não foram configuradas corretamente');\r\n        }\r\n        // Gerar número aleatório entre 0 e o total de taxas\r\n        const random = Math.random() * totalDropRate;\r\n        // Selecionar item baseado na taxa de drop\r\n        let currentSum = 0;\r\n        for (const item of items) {\r\n            currentSum += (item.dropRate || 0);\r\n            if (random <= currentSum) {\r\n                return item;\r\n            }\r\n        }\r\n        // Fallback (não deveria acontecer, mas por segurança)\r\n        return items[items.length - 1];\r\n    }\r\n    async removeItemFromUser(userItemId, quantity = 1) {\r\n        await this.http.post(`${environment.backendUrl}/userItems/${userItemId}/remove`, { quantity }).toPromise();\r\n    }\r\n}\r\nItemService.ɵfac = function ItemService_Factory(t) { return new (t || ItemService)(i0.ɵɵinject(i1.HttpClient)); };\r\nItemService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ItemService, factory: ItemService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}