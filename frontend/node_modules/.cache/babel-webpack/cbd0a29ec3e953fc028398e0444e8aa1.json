{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./user.service\";\nexport let ProfileService = /*#__PURE__*/(() => {\n  class ProfileService {\n    constructor(http, userService) {\n      this.http = http;\n      this.userService = userService;\n      this.iconsIndexPath = 'assets/avatares/index.json';\n    } // Lista de ícones disponíveis, organizados por categoria/anime.\n    // O arquivo `assets/avatares/index.json` pode ser:\n    // 1) um array simples de caminhos: [\"assets/...png\", ...]\n    // 2) um objeto por categorias: { \"Naruto\": [\"assets/...png\"], \"OnePiece\": [...] }\n\n\n    listAvailableIconsGrouped() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          const res = yield _this.http.get(_this.iconsIndexPath).toPromise();\n          if (!res) return {}; // se for array simples, colocar em 'Geral'\n\n          if (Array.isArray(res)) {\n            return {\n              Geral: res\n            };\n          } // se for objeto, assumir que já está no formato desejado\n\n\n          return res;\n        } catch (error) {\n          console.error('Erro ao listar icons agrupados:', error);\n          return {};\n        }\n      })();\n    } // lista de fundos disponíveis para perfil (assets/backgrounds/index.json)\n\n\n    listAvailableBackgrounds() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          const res = yield _this2.http.get('assets/backgrounds/index.json').toPromise();\n          if (!res) return [];\n          let files = [];\n          if (Array.isArray(res)) files = res;else files = Object.keys(res).reduce((acc, k) => acc.concat(res[k] || []), []);\n          return files.map(f => ({\n            src: f,\n            type: /\\.(webm|mp4)$/i.test(f) ? 'video' : /\\.(gif)$/i.test(f) ? 'gif' : 'image'\n          }));\n        } catch (error) {\n          console.error('Erro ao listar backgrounds:', error);\n          return [];\n        }\n      })();\n    } // Busca perfil (merge com doc de usuário)\n\n\n    getProfile(userId) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          const user = yield _this3.userService.getUserById(userId);\n          if (!user) return null; // Sempre usar o `username` do documento de usuário como nome de exibição\n\n          const profile = {\n            displayName: user.username,\n            profileIcon: user.profileIcon || user.photoURL,\n            profileBackground: user.profileBackground || '',\n            description: user.description || '',\n            showcasedCards: user.showcasedCards || []\n          };\n          return profile;\n        } catch (error) {\n          console.error('Erro ao obter profile:', error);\n          return null;\n        }\n      })();\n    }\n\n    updateProfile(userId, profile) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          // Construir payload apenas com campos definidos (Firestore rejeita `undefined`)\n          const payload = {}; // displayName não é mais usado - username é fixo\n          // if (typeof profile.displayName !== 'undefined') payload.displayName = profile.displayName;\n\n          if (typeof profile.profileIcon !== 'undefined') payload.profileIcon = profile.profileIcon;\n          if (typeof profile.profileBackground !== 'undefined') payload.profileBackground = profile.profileBackground;\n          if (typeof profile.description !== 'undefined') payload.description = profile.description;\n          if (typeof profile.showcasedCards !== 'undefined') payload.showcasedCards = profile.showcasedCards; // Se não há nada para atualizar, sair sem chamar o Firestore\n\n          if (Object.keys(payload).length === 0) return;\n          yield _this4.userService.updateUser(userId, payload);\n        } catch (error) {\n          console.error('Erro ao atualizar profile:', error);\n          throw error;\n        }\n      })();\n    }\n\n  }\n\n  ProfileService.ɵfac = function ProfileService_Factory(t) {\n    return new (t || ProfileService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService));\n  };\n\n  ProfileService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ProfileService,\n    factory: ProfileService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProfileService;\n})();","map":null,"metadata":{},"sourceType":"module"}