{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class ItemService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  createItem(item) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this.http.post(`${environment.backendUrl}/items`, item).toPromise();\n      return result.id;\n    })();\n  }\n\n  getAllItems() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this2.http.get(`${environment.backendUrl}/items`).toPromise();\n    })();\n  }\n\n  getItemsByBox(boxId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this3.http.get(`${environment.backendUrl}/items/by-box/${boxId}`).toPromise();\n    })();\n  }\n\n  getItemById(itemId) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield _this4.http.get(`${environment.backendUrl}/items/${itemId}`).toPromise();\n      return data ? Object.assign({\n        id: itemId\n      }, data) : null;\n    })();\n  }\n\n  updateItem(itemId, data) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.http.put(`${environment.backendUrl}/items/${itemId}`, data).toPromise();\n    })();\n  } // Função auxiliar para calcular pontos baseado na raridade e rarityLevel\n\n\n  calculateItemPoints(rarity, rarityLevel) {\n    const rarityPoints = {\n      'COMUM': 10,\n      'RARO': 25,\n      'EPICO': 50,\n      'LENDARIO': 100,\n      'MITICO': 200\n    };\n    let points = rarityPoints[rarity] || 10; // Aplicar multiplicador baseado no rarityLevel se existir\n\n    if (rarityLevel && typeof rarityLevel === 'number') {\n      const rarityMultiplier = 1 + (1000 - rarityLevel) / 1000;\n      points = Math.round(points * rarityMultiplier);\n    }\n\n    return points;\n  }\n\n  migrateItemsWithoutPoints() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* (forceRecalculate = false) {\n      // Busca todos os documentos diretamente do Firestore para verificar campos brutos\n      const querySnapshot = yield getDocs(collection(_this6.db, 'items'));\n      const itemsToUpdate = [];\n      const allItems = [];\n      const mode = forceRecalculate ? '(MODO FORÇADO - RECALCULAR TODOS)' : '';\n      console.log(`Verificando todos os itens no banco... ${mode}`);\n      querySnapshot.forEach(doc => {\n        const data = doc.data();\n        allItems.push({\n          id: doc.id,\n          name: data.name,\n          rarity: data.rarity,\n          rarityLevel: data.rarityLevel,\n          points: data.points,\n          hasPointsField: data.hasOwnProperty('points')\n        }); // Se for modo forçado, recalcular todos os itens\n\n        if (forceRecalculate) {\n          itemsToUpdate.push(Object.assign({\n            id: doc.id\n          }, data));\n        } else {\n          // Modo normal: só itens sem pontos válidos\n          const needsMigration = !data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0;\n\n          if (needsMigration) {\n            itemsToUpdate.push(Object.assign({\n              id: doc.id\n            }, data));\n          }\n        }\n      });\n      console.log('Todos os itens encontrados:', allItems);\n      console.log(`Encontrados ${itemsToUpdate.length} itens para atualizar pontos`);\n\n      if (itemsToUpdate.length === 0 && !forceRecalculate) {\n        console.log('Nenhum item precisa de migracao. Verificando se ha itens com points = 0...'); // Verificar especificamente itens com points = 0\n\n        const itemsWithZeroPoints = allItems.filter(item => item.points === 0);\n\n        if (itemsWithZeroPoints.length > 0) {\n          console.log('Encontrados itens com points = 0. Forcando migracao...', itemsWithZeroPoints); // Adicionar itens com points = 0 à lista de atualização\n\n          querySnapshot.forEach(doc => {\n            const data = doc.data();\n\n            if (data.points === 0) {\n              itemsToUpdate.push(Object.assign({\n                id: doc.id\n              }, data));\n            }\n          });\n        } else {\n          console.log('Todos os itens ja tem pontos validos (> 0).');\n          console.log('Dica: Use migrateItemsWithoutPoints(true) para forcar recalculo de todos os pontos.');\n          return;\n        }\n      } // Define pontos baseados na raridade\n\n\n      const rarityPoints = {\n        'COMUM': 10,\n        'RARO': 25,\n        'EPICO': 50,\n        'LENDARIO': 100,\n        'MITICO': 200\n      };\n\n      for (const itemData of itemsToUpdate) {\n        console.log(`Processando item: ${itemData.name}`, {\n          rarity: itemData.rarity,\n          rarityLevel: itemData.rarityLevel,\n          hasRarityLevel: itemData.hasOwnProperty('rarityLevel'),\n          rarityLevelType: typeof itemData.rarityLevel\n        });\n        let points = rarityPoints[itemData.rarity] || 10;\n        console.log(`Pontos base calculados: ${points} para raridade ${itemData.rarity}`); // Aplicar multiplicador baseado no rarityLevel PARA TODOS os itens\n\n        if (itemData.rarityLevel && typeof itemData.rarityLevel === 'number') {\n          const rarityMultiplier = 1 + (1000 - itemData.rarityLevel) / 1000; // 1.0 a 2.0\n\n          const oldPoints = points;\n          points = Math.round(points * rarityMultiplier);\n          console.log(`Aplicando multiplicador: ${oldPoints} x ${rarityMultiplier.toFixed(3)} = ${points} (rarityLevel: ${itemData.rarityLevel})`);\n        } else {\n          console.log(`Sem rarityLevel ou invalido: ${itemData.rarityLevel}`);\n        }\n\n        console.log(`Salvando item ${itemData.name} com ${points} pontos`);\n        yield _this6.updateItem(itemData.id, {\n          points\n        });\n        console.log(`Atualizado item ${itemData.name} com points = ${points}`);\n      }\n\n      console.log('Migração concluída');\n    }).apply(this, arguments);\n  }\n\n  migrateUserItemsPoints() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      console.log('Iniciando migracao de pontos para userItems...'); // Buscar todos os userItems\n\n      const querySnapshot = yield getDocs(collection(_this7.db, 'userItems'));\n      const userItemsToUpdate = [];\n      querySnapshot.forEach(doc => {\n        const data = doc.data(); // Verificar se não tem pontos ou pontos = 0\n\n        if (!data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0) {\n          userItemsToUpdate.push(Object.assign({\n            id: doc.id\n          }, data));\n        }\n      });\n      console.log(`Encontrados ${userItemsToUpdate.length} userItems para atualizar pontos`);\n\n      if (userItemsToUpdate.length === 0) {\n        console.log('Todos os userItems ja tem pontos validos.');\n        return;\n      }\n\n      for (const userItemData of userItemsToUpdate) {\n        // Se não tem item aninhado, buscar pelo itemId\n        let itemRarity = (_a = userItemData.item) === null || _a === void 0 ? void 0 : _a.rarity;\n\n        if (!itemRarity && userItemData.itemId) {\n          const item = yield _this7.getItemById(userItemData.itemId);\n          itemRarity = item === null || item === void 0 ? void 0 : item.rarity;\n        }\n\n        if (!itemRarity) {\n          console.log(`Nao foi possivel determinar raridade para userItem ${userItemData.id}`);\n          continue;\n        }\n\n        const points = _this7.calculateItemPoints(itemRarity, userItemData.rarityLevel);\n\n        console.log(`Migrando userItem ${userItemData.id}: raridade ${itemRarity}, rarityLevel ${userItemData.rarityLevel}, pontos ${points}`);\n        yield updateDoc(doc(_this7.db, 'userItems', userItemData.id), {\n          points\n        });\n        console.log(`Atualizado userItem ${userItemData.id} com points = ${points}`);\n      }\n\n      console.log('Migracao de userItems concluida!');\n    })();\n  }\n\n  deleteItem(itemId) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const docRef = doc(_this8.db, 'items', itemId);\n      yield deleteDoc(docRef);\n    })();\n  }\n\n  deleteAllItems() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      console.log('Deletando todos os itens...');\n      const items = yield _this9.getAllItems();\n      console.log(`Encontrados ${items.length} itens para deletar`);\n\n      for (const item of items) {\n        console.log(`Deletando ${item.name}...`);\n        yield _this9.deleteItem(item.id);\n      }\n\n      console.log('Todos os itens foram deletados!');\n    })();\n  }\n\n  addItemToUser(userId, itemId, rarityLevel) {\n    var _this0 = this;\n\n    return _asyncToGenerator(function* () {\n      const item = yield _this0.getItemById(itemId);\n      if (!item) throw new Error('Item não encontrado'); // Para itens lendários e míticos, garantir rarityLevel único\n\n      let finalRarityLevel;\n\n      if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\n        if (rarityLevel) {\n          // Verificar se o rarityLevel fornecido já existe para este item\n          const exists = yield _this0.checkRarityLevelExists(itemId, rarityLevel, userId);\n\n          if (exists) {\n            throw new Error('Este nível de raridade já existe para este item');\n          }\n\n          finalRarityLevel = rarityLevel;\n        } else {\n          // Gerar rarityLevel único\n          finalRarityLevel = yield _this0.generateUniqueRarityLevel(itemId, userId);\n        }\n      } else {\n        // Para outros itens, usar o rarityLevel fornecido ou gerar aleatório\n        finalRarityLevel = rarityLevel !== null && rarityLevel !== void 0 ? rarityLevel : Math.floor(Math.random() * 1000) + 1;\n      } // Calcular pontos baseado na raridade e rarityLevel\n\n\n      const points = _this0.calculateItemPoints(item.rarity, finalRarityLevel); // Para itens lendários e míticos, cada cópia é tratada como item único\n\n\n      if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\n        // Criar entrada única para cada item lendário/mítico\n        const uniqueId = `${userId}_${itemId}_${Date.now()}_${finalRarityLevel}`;\n        const docRef = doc(_this0.db, 'userItems', uniqueId);\n        const userItemData = {\n          userId,\n          itemId,\n          item,\n          obtainedAt: new Date(),\n          quantity: 1,\n          rarityLevel: finalRarityLevel,\n          points\n        };\n        yield setDoc(docRef, userItemData);\n        return finalRarityLevel;\n      } else {\n        // Para itens comuns, raros e épicos, manter o sistema atual\n        const userItemId = `${userId}_${itemId}`;\n        const docRef = doc(_this0.db, 'userItems', userItemId);\n        const docSnap = yield getDoc(docRef);\n\n        if (docSnap.exists()) {\n          const currentData = docSnap.data();\n          yield updateDoc(docRef, {\n            quantity: currentData['quantity'] + 1,\n            points: Math.max(currentData['points'] || 0, points)\n          });\n          return 0; // No rarity level for common items\n        } else {\n          const userItemData = {\n            userId,\n            itemId,\n            item,\n            obtainedAt: new Date(),\n            quantity: 1,\n            points\n          };\n          yield setDoc(docRef, userItemData);\n          return 0;\n        }\n      }\n    })();\n  }\n\n  getUserItems(userId) {\n    var _this1 = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield _this1.http.get(`${environment.backendUrl}/userItems/user/${userId}`).toPromise();\n      const userItems = yield Promise.all(data.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (ui) {\n          const item = yield _this1.getItemById(ui.itemId);\n          return Object.assign(Object.assign({\n            id: ui.id\n          }, ui), {\n            item\n          });\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return userItems;\n    })();\n  }\n\n  getUserItemById(id) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield _this10.http.get(`${environment.backendUrl}/userItems/${id}`).toPromise();\n\n      if (data) {\n        const item = yield _this10.getItemById(data.itemId);\n        return Object.assign(Object.assign({\n          id\n        }, data), {\n          item\n        });\n      }\n\n      return null;\n    })();\n  }\n\n  getUserRarestItemInBox(userId, boxId) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const userItems = yield _this11.getUserItems(userId);\n      const boxItems = userItems.filter(ui => ui.item.boxId === boxId);\n      if (boxItems.length === 0) return null;\n      boxItems.sort((a, b) => {\n        // Calcular score baseado na raridade e rarityLevel\n        let scoreA = a.item.points || 0;\n        let scoreB = b.item.points || 0; // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\n\n        if ((a.item.rarity === 'LENDARIO' || a.item.rarity === 'MITICO') && a.rarityLevel) {\n          const rarityMultiplierA = 1 + (1000 - a.rarityLevel) / 1000;\n          scoreA = scoreA * rarityMultiplierA;\n        }\n\n        if ((b.item.rarity === 'LENDARIO' || b.item.rarity === 'MITICO') && b.rarityLevel) {\n          const rarityMultiplierB = 1 + (1000 - b.rarityLevel) / 1000;\n          scoreB = scoreB * rarityMultiplierB;\n        }\n\n        return scoreB - scoreA; // Ordenação decrescente\n      });\n      return boxItems[0];\n    })();\n  } // Verificar se um rarityLevel já existe para um item específico\n\n\n  checkRarityLevelExists(itemId, rarityLevel, excludeUserId) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const q = query(collection(_this12.db, 'userItems'), where('itemId', '==', itemId), where('rarityLevel', '==', rarityLevel));\n      const querySnapshot = yield getDocs(q); // Se excludeUserId for fornecido, excluir itens desse usuário\n\n      const existingItems = querySnapshot.docs.filter(doc => {\n        const data = doc.data();\n        return !excludeUserId || data['userId'] !== excludeUserId;\n      });\n      return existingItems.length > 0;\n    })();\n  } // Gerar um rarityLevel único para um item\n\n\n  generateUniqueRarityLevel(itemId, userId) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const maxAttempts = 1000; // Evitar loop infinito\n\n      let attempts = 0;\n\n      while (attempts < maxAttempts) {\n        const rarityLevel = Math.floor(Math.random() * 1000) + 1;\n        const exists = yield _this13.checkRarityLevelExists(itemId, rarityLevel, userId);\n\n        if (!exists) {\n          return rarityLevel;\n        }\n\n        attempts++;\n      } // Se não conseguir gerar único após muitas tentativas, usar timestamp como base\n\n\n      const timestampBased = Date.now() % 1000 + 1;\n      return Math.min(timestampBased, 1000);\n    })();\n  }\n\n  drawRandomItem(boxId) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const items = yield _this14.getItemsByBox(boxId);\n      if (items.length === 0) throw new Error('Nenhum item disponível nesta caixa'); // Usar as taxas de drop configuradas para cada item\n\n      const totalDropRate = items.reduce((sum, item) => sum + (item.dropRate || 0), 0);\n\n      if (totalDropRate === 0) {\n        throw new Error('As taxas de drop dos itens não foram configuradas corretamente');\n      } // Gerar número aleatório entre 0 e o total de taxas\n\n\n      const random = Math.random() * totalDropRate; // Selecionar item baseado na taxa de drop\n\n      let currentSum = 0;\n\n      for (const item of items) {\n        currentSum += item.dropRate || 0;\n\n        if (random <= currentSum) {\n          return item;\n        }\n      } // Fallback (não deveria acontecer, mas por segurança)\n\n\n      return items[items.length - 1];\n    })();\n  }\n\n  removeItemFromUser(_x2) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* (userItemId, quantity = 1) {\n      const docRef = doc(_this15.db, 'userItems', userItemId);\n      const docSnap = yield getDoc(docRef);\n\n      if (docSnap.exists()) {\n        const data = docSnap.data();\n\n        if (data.quantity > quantity) {\n          // Decrement quantity\n          yield updateDoc(docRef, {\n            quantity: data.quantity - quantity\n          });\n        } else {\n          // Delete the document\n          yield deleteDoc(docRef);\n        }\n      }\n    }).apply(this, arguments);\n  }\n\n}\n\nItemService.ɵfac = function ItemService_Factory(t) {\n  return new (t || ItemService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nItemService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ItemService,\n  factory: ItemService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/item.service.ts"],"names":["environment","i0","i1","ItemService","constructor","http","createItem","item","result","post","backendUrl","toPromise","id","getAllItems","get","getItemsByBox","boxId","getItemById","itemId","data","Object","assign","updateItem","put","calculateItemPoints","rarity","rarityLevel","rarityPoints","points","rarityMultiplier","Math","round","migrateItemsWithoutPoints","forceRecalculate","querySnapshot","getDocs","collection","db","itemsToUpdate","allItems","mode","console","log","forEach","doc","push","name","hasPointsField","hasOwnProperty","needsMigration","undefined","length","itemsWithZeroPoints","filter","itemData","hasRarityLevel","rarityLevelType","oldPoints","toFixed","migrateUserItemsPoints","_a","userItemsToUpdate","userItemData","itemRarity","updateDoc","deleteItem","docRef","deleteDoc","deleteAllItems","items","addItemToUser","userId","Error","finalRarityLevel","exists","checkRarityLevelExists","generateUniqueRarityLevel","floor","random","uniqueId","Date","now","obtainedAt","quantity","setDoc","userItemId","docSnap","getDoc","currentData","max","getUserItems","userItems","Promise","all","map","ui","getUserItemById","getUserRarestItemInBox","boxItems","sort","a","b","scoreA","scoreB","rarityMultiplierA","rarityMultiplierB","excludeUserId","q","query","where","existingItems","docs","maxAttempts","attempts","timestampBased","min","drawRandomItem","totalDropRate","reduce","sum","dropRate","currentSum","removeItemFromUser","ɵfac","ItemService_Factory","t","ɵɵinject","HttpClient","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { environment } from '../../environments/environment';\r\nimport * as i0 from \"@angular/core\";\r\nimport * as i1 from \"@angular/common/http\";\r\nexport class ItemService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    async createItem(item) {\r\n        const result = await this.http.post(`${environment.backendUrl}/items`, item).toPromise();\r\n        return result.id;\r\n    }\r\n    async getAllItems() {\r\n        return await this.http.get(`${environment.backendUrl}/items`).toPromise();\r\n    }\r\n    async getItemsByBox(boxId) {\r\n        return await this.http.get(`${environment.backendUrl}/items/by-box/${boxId}`).toPromise();\r\n    }\r\n    async getItemById(itemId) {\r\n        const data = await this.http.get(`${environment.backendUrl}/items/${itemId}`).toPromise();\r\n        return data ? Object.assign({ id: itemId }, data) : null;\r\n    }\r\n    async updateItem(itemId, data) {\r\n        await this.http.put(`${environment.backendUrl}/items/${itemId}`, data).toPromise();\r\n    }\r\n    // Função auxiliar para calcular pontos baseado na raridade e rarityLevel\r\n    calculateItemPoints(rarity, rarityLevel) {\r\n        const rarityPoints = {\r\n            'COMUM': 10,\r\n            'RARO': 25,\r\n            'EPICO': 50,\r\n            'LENDARIO': 100,\r\n            'MITICO': 200\r\n        };\r\n        let points = rarityPoints[rarity] || 10;\r\n        // Aplicar multiplicador baseado no rarityLevel se existir\r\n        if (rarityLevel && typeof rarityLevel === 'number') {\r\n            const rarityMultiplier = 1 + ((1000 - rarityLevel) / 1000);\r\n            points = Math.round(points * rarityMultiplier);\r\n        }\r\n        return points;\r\n    }\r\n    async migrateItemsWithoutPoints(forceRecalculate = false) {\r\n        // Busca todos os documentos diretamente do Firestore para verificar campos brutos\r\n        const querySnapshot = await getDocs(collection(this.db, 'items'));\r\n        const itemsToUpdate = [];\r\n        const allItems = [];\r\n        const mode = forceRecalculate ? '(MODO FORÇADO - RECALCULAR TODOS)' : '';\r\n        console.log(`Verificando todos os itens no banco... ${mode}`);\r\n        querySnapshot.forEach(doc => {\r\n            const data = doc.data();\r\n            allItems.push({\r\n                id: doc.id,\r\n                name: data.name,\r\n                rarity: data.rarity,\r\n                rarityLevel: data.rarityLevel,\r\n                points: data.points,\r\n                hasPointsField: data.hasOwnProperty('points')\r\n            });\r\n            // Se for modo forçado, recalcular todos os itens\r\n            if (forceRecalculate) {\r\n                itemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n            }\r\n            else {\r\n                // Modo normal: só itens sem pontos válidos\r\n                const needsMigration = !data.hasOwnProperty('points') ||\r\n                    data.points === null ||\r\n                    data.points === undefined ||\r\n                    data.points === 0;\r\n                if (needsMigration) {\r\n                    itemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n                }\r\n            }\r\n        });\r\n        console.log('Todos os itens encontrados:', allItems);\r\n        console.log(`Encontrados ${itemsToUpdate.length} itens para atualizar pontos`);\r\n        if (itemsToUpdate.length === 0 && !forceRecalculate) {\r\n            console.log('Nenhum item precisa de migracao. Verificando se ha itens com points = 0...');\r\n            // Verificar especificamente itens com points = 0\r\n            const itemsWithZeroPoints = allItems.filter(item => item.points === 0);\r\n            if (itemsWithZeroPoints.length > 0) {\r\n                console.log('Encontrados itens com points = 0. Forcando migracao...', itemsWithZeroPoints);\r\n                // Adicionar itens com points = 0 à lista de atualização\r\n                querySnapshot.forEach(doc => {\r\n                    const data = doc.data();\r\n                    if (data.points === 0) {\r\n                        itemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                console.log('Todos os itens ja tem pontos validos (> 0).');\r\n                console.log('Dica: Use migrateItemsWithoutPoints(true) para forcar recalculo de todos os pontos.');\r\n                return;\r\n            }\r\n        }\r\n        // Define pontos baseados na raridade\r\n        const rarityPoints = {\r\n            'COMUM': 10,\r\n            'RARO': 25,\r\n            'EPICO': 50,\r\n            'LENDARIO': 100,\r\n            'MITICO': 200\r\n        };\r\n        for (const itemData of itemsToUpdate) {\r\n            console.log(`Processando item: ${itemData.name}`, {\r\n                rarity: itemData.rarity,\r\n                rarityLevel: itemData.rarityLevel,\r\n                hasRarityLevel: itemData.hasOwnProperty('rarityLevel'),\r\n                rarityLevelType: typeof itemData.rarityLevel\r\n            });\r\n            let points = rarityPoints[itemData.rarity] || 10;\r\n            console.log(`Pontos base calculados: ${points} para raridade ${itemData.rarity}`);\r\n            // Aplicar multiplicador baseado no rarityLevel PARA TODOS os itens\r\n            if (itemData.rarityLevel && typeof itemData.rarityLevel === 'number') {\r\n                const rarityMultiplier = 1 + ((1000 - itemData.rarityLevel) / 1000); // 1.0 a 2.0\r\n                const oldPoints = points;\r\n                points = Math.round(points * rarityMultiplier);\r\n                console.log(`Aplicando multiplicador: ${oldPoints} x ${rarityMultiplier.toFixed(3)} = ${points} (rarityLevel: ${itemData.rarityLevel})`);\r\n            }\r\n            else {\r\n                console.log(`Sem rarityLevel ou invalido: ${itemData.rarityLevel}`);\r\n            }\r\n            console.log(`Salvando item ${itemData.name} com ${points} pontos`);\r\n            await this.updateItem(itemData.id, { points });\r\n            console.log(`Atualizado item ${itemData.name} com points = ${points}`);\r\n        }\r\n        console.log('Migração concluída');\r\n    }\r\n    async migrateUserItemsPoints() {\r\n        var _a;\r\n        console.log('Iniciando migracao de pontos para userItems...');\r\n        // Buscar todos os userItems\r\n        const querySnapshot = await getDocs(collection(this.db, 'userItems'));\r\n        const userItemsToUpdate = [];\r\n        querySnapshot.forEach(doc => {\r\n            const data = doc.data();\r\n            // Verificar se não tem pontos ou pontos = 0\r\n            if (!data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0) {\r\n                userItemsToUpdate.push(Object.assign({ id: doc.id }, data));\r\n            }\r\n        });\r\n        console.log(`Encontrados ${userItemsToUpdate.length} userItems para atualizar pontos`);\r\n        if (userItemsToUpdate.length === 0) {\r\n            console.log('Todos os userItems ja tem pontos validos.');\r\n            return;\r\n        }\r\n        for (const userItemData of userItemsToUpdate) {\r\n            // Se não tem item aninhado, buscar pelo itemId\r\n            let itemRarity = (_a = userItemData.item) === null || _a === void 0 ? void 0 : _a.rarity;\r\n            if (!itemRarity && userItemData.itemId) {\r\n                const item = await this.getItemById(userItemData.itemId);\r\n                itemRarity = item === null || item === void 0 ? void 0 : item.rarity;\r\n            }\r\n            if (!itemRarity) {\r\n                console.log(`Nao foi possivel determinar raridade para userItem ${userItemData.id}`);\r\n                continue;\r\n            }\r\n            const points = this.calculateItemPoints(itemRarity, userItemData.rarityLevel);\r\n            console.log(`Migrando userItem ${userItemData.id}: raridade ${itemRarity}, rarityLevel ${userItemData.rarityLevel}, pontos ${points}`);\r\n            await updateDoc(doc(this.db, 'userItems', userItemData.id), { points });\r\n            console.log(`Atualizado userItem ${userItemData.id} com points = ${points}`);\r\n        }\r\n        console.log('Migracao de userItems concluida!');\r\n    }\r\n    async deleteItem(itemId) {\r\n        const docRef = doc(this.db, 'items', itemId);\r\n        await deleteDoc(docRef);\r\n    }\r\n    async deleteAllItems() {\r\n        console.log('Deletando todos os itens...');\r\n        const items = await this.getAllItems();\r\n        console.log(`Encontrados ${items.length} itens para deletar`);\r\n        for (const item of items) {\r\n            console.log(`Deletando ${item.name}...`);\r\n            await this.deleteItem(item.id);\r\n        }\r\n        console.log('Todos os itens foram deletados!');\r\n    }\r\n    async addItemToUser(userId, itemId, rarityLevel) {\r\n        const item = await this.getItemById(itemId);\r\n        if (!item)\r\n            throw new Error('Item não encontrado');\r\n        // Para itens lendários e míticos, garantir rarityLevel único\r\n        let finalRarityLevel;\r\n        if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\r\n            if (rarityLevel) {\r\n                // Verificar se o rarityLevel fornecido já existe para este item\r\n                const exists = await this.checkRarityLevelExists(itemId, rarityLevel, userId);\r\n                if (exists) {\r\n                    throw new Error('Este nível de raridade já existe para este item');\r\n                }\r\n                finalRarityLevel = rarityLevel;\r\n            }\r\n            else {\r\n                // Gerar rarityLevel único\r\n                finalRarityLevel = await this.generateUniqueRarityLevel(itemId, userId);\r\n            }\r\n        }\r\n        else {\r\n            // Para outros itens, usar o rarityLevel fornecido ou gerar aleatório\r\n            finalRarityLevel = rarityLevel !== null && rarityLevel !== void 0 ? rarityLevel : Math.floor(Math.random() * 1000) + 1;\r\n        }\r\n        // Calcular pontos baseado na raridade e rarityLevel\r\n        const points = this.calculateItemPoints(item.rarity, finalRarityLevel);\r\n        // Para itens lendários e míticos, cada cópia é tratada como item único\r\n        if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\r\n            // Criar entrada única para cada item lendário/mítico\r\n            const uniqueId = `${userId}_${itemId}_${Date.now()}_${finalRarityLevel}`;\r\n            const docRef = doc(this.db, 'userItems', uniqueId);\r\n            const userItemData = {\r\n                userId,\r\n                itemId,\r\n                item,\r\n                obtainedAt: new Date(),\r\n                quantity: 1,\r\n                rarityLevel: finalRarityLevel,\r\n                points\r\n            };\r\n            await setDoc(docRef, userItemData);\r\n            return finalRarityLevel;\r\n        }\r\n        else {\r\n            // Para itens comuns, raros e épicos, manter o sistema atual\r\n            const userItemId = `${userId}_${itemId}`;\r\n            const docRef = doc(this.db, 'userItems', userItemId);\r\n            const docSnap = await getDoc(docRef);\r\n            if (docSnap.exists()) {\r\n                const currentData = docSnap.data();\r\n                await updateDoc(docRef, {\r\n                    quantity: currentData['quantity'] + 1,\r\n                    points: Math.max(currentData['points'] || 0, points)\r\n                });\r\n                return 0; // No rarity level for common items\r\n            }\r\n            else {\r\n                const userItemData = {\r\n                    userId,\r\n                    itemId,\r\n                    item,\r\n                    obtainedAt: new Date(),\r\n                    quantity: 1,\r\n                    points\r\n                };\r\n                await setDoc(docRef, userItemData);\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    async getUserItems(userId) {\r\n        const data = await this.http.get(`${environment.backendUrl}/userItems/user/${userId}`).toPromise();\r\n        const userItems = await Promise.all(data.map(async (ui) => {\r\n            const item = await this.getItemById(ui.itemId);\r\n            return Object.assign(Object.assign({ id: ui.id }, ui), { item });\r\n        }));\r\n        return userItems;\r\n    }\r\n    async getUserItemById(id) {\r\n        const data = await this.http.get(`${environment.backendUrl}/userItems/${id}`).toPromise();\r\n        if (data) {\r\n            const item = await this.getItemById(data.itemId);\r\n            return Object.assign(Object.assign({ id }, data), { item });\r\n        }\r\n        return null;\r\n    }\r\n    async getUserRarestItemInBox(userId, boxId) {\r\n        const userItems = await this.getUserItems(userId);\r\n        const boxItems = userItems.filter(ui => ui.item.boxId === boxId);\r\n        if (boxItems.length === 0)\r\n            return null;\r\n        boxItems.sort((a, b) => {\r\n            // Calcular score baseado na raridade e rarityLevel\r\n            let scoreA = a.item.points || 0;\r\n            let scoreB = b.item.points || 0;\r\n            // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\r\n            if ((a.item.rarity === 'LENDARIO' || a.item.rarity === 'MITICO') && a.rarityLevel) {\r\n                const rarityMultiplierA = 1 + ((1000 - a.rarityLevel) / 1000);\r\n                scoreA = scoreA * rarityMultiplierA;\r\n            }\r\n            if ((b.item.rarity === 'LENDARIO' || b.item.rarity === 'MITICO') && b.rarityLevel) {\r\n                const rarityMultiplierB = 1 + ((1000 - b.rarityLevel) / 1000);\r\n                scoreB = scoreB * rarityMultiplierB;\r\n            }\r\n            return scoreB - scoreA; // Ordenação decrescente\r\n        });\r\n        return boxItems[0];\r\n    }\r\n    // Verificar se um rarityLevel já existe para um item específico\r\n    async checkRarityLevelExists(itemId, rarityLevel, excludeUserId) {\r\n        const q = query(collection(this.db, 'userItems'), where('itemId', '==', itemId), where('rarityLevel', '==', rarityLevel));\r\n        const querySnapshot = await getDocs(q);\r\n        // Se excludeUserId for fornecido, excluir itens desse usuário\r\n        const existingItems = querySnapshot.docs.filter(doc => {\r\n            const data = doc.data();\r\n            return !excludeUserId || data['userId'] !== excludeUserId;\r\n        });\r\n        return existingItems.length > 0;\r\n    }\r\n    // Gerar um rarityLevel único para um item\r\n    async generateUniqueRarityLevel(itemId, userId) {\r\n        const maxAttempts = 1000; // Evitar loop infinito\r\n        let attempts = 0;\r\n        while (attempts < maxAttempts) {\r\n            const rarityLevel = Math.floor(Math.random() * 1000) + 1;\r\n            const exists = await this.checkRarityLevelExists(itemId, rarityLevel, userId);\r\n            if (!exists) {\r\n                return rarityLevel;\r\n            }\r\n            attempts++;\r\n        }\r\n        // Se não conseguir gerar único após muitas tentativas, usar timestamp como base\r\n        const timestampBased = (Date.now() % 1000) + 1;\r\n        return Math.min(timestampBased, 1000);\r\n    }\r\n    async drawRandomItem(boxId) {\r\n        const items = await this.getItemsByBox(boxId);\r\n        if (items.length === 0)\r\n            throw new Error('Nenhum item disponível nesta caixa');\r\n        // Usar as taxas de drop configuradas para cada item\r\n        const totalDropRate = items.reduce((sum, item) => sum + (item.dropRate || 0), 0);\r\n        if (totalDropRate === 0) {\r\n            throw new Error('As taxas de drop dos itens não foram configuradas corretamente');\r\n        }\r\n        // Gerar número aleatório entre 0 e o total de taxas\r\n        const random = Math.random() * totalDropRate;\r\n        // Selecionar item baseado na taxa de drop\r\n        let currentSum = 0;\r\n        for (const item of items) {\r\n            currentSum += (item.dropRate || 0);\r\n            if (random <= currentSum) {\r\n                return item;\r\n            }\r\n        }\r\n        // Fallback (não deveria acontecer, mas por segurança)\r\n        return items[items.length - 1];\r\n    }\r\n    async removeItemFromUser(userItemId, quantity = 1) {\r\n        const docRef = doc(this.db, 'userItems', userItemId);\r\n        const docSnap = await getDoc(docRef);\r\n        if (docSnap.exists()) {\r\n            const data = docSnap.data();\r\n            if (data.quantity > quantity) {\r\n                // Decrement quantity\r\n                await updateDoc(docRef, {\r\n                    quantity: data.quantity - quantity\r\n                });\r\n            }\r\n            else {\r\n                // Delete the document\r\n                await deleteDoc(docRef);\r\n            }\r\n        }\r\n    }\r\n}\r\nItemService.ɵfac = function ItemService_Factory(t) { return new (t || ItemService)(i0.ɵɵinject(i1.HttpClient)); };\r\nItemService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ItemService, factory: ItemService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}