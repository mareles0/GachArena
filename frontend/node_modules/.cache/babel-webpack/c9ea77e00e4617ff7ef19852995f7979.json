{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { getFirestore, doc, getDoc, setDoc, updateDoc, increment } from 'firebase/firestore';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class TicketService {\n  constructor() {\n    this.db = getFirestore();\n    this.ticketsSubject = new BehaviorSubject({\n      normalTickets: 0,\n      premiumTickets: 0\n    });\n    this.tickets$ = this.ticketsSubject.asObservable();\n  }\n\n  getUserTickets(userId) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const docRef = doc(_this.db, 'users', userId);\n      const docSnap = yield getDoc(docRef);\n\n      if (docSnap.exists()) {\n        const data = docSnap.data();\n        const tickets = {\n          normalTickets: data.normalTickets || 0,\n          premiumTickets: data.premiumTickets || 0\n        };\n\n        _this.ticketsSubject.next(tickets);\n\n        return tickets;\n      }\n\n      const defaultTickets = {\n        normalTickets: 0,\n        premiumTickets: 0\n      };\n\n      _this.ticketsSubject.next(defaultTickets);\n\n      return defaultTickets;\n    })();\n  }\n\n  useTicket(userId, type) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const tickets = yield _this2.getUserTickets(userId);\n      const docRef = doc(_this2.db, 'users', userId);\n\n      if (type === 'NORMAL' && tickets.normalTickets > 0) {\n        yield updateDoc(docRef, {\n          normalTickets: increment(-1)\n        }); // Atualizar o subject após usar ticket\n\n        const updatedTickets = Object.assign(Object.assign({}, tickets), {\n          normalTickets: tickets.normalTickets - 1\n        });\n\n        _this2.ticketsSubject.next(updatedTickets);\n\n        return true;\n      } else if (type === 'PREMIUM' && tickets.premiumTickets > 0) {\n        yield updateDoc(docRef, {\n          premiumTickets: increment(-1)\n        }); // Atualizar o subject após usar ticket\n\n        const updatedTickets = Object.assign(Object.assign({}, tickets), {\n          premiumTickets: tickets.premiumTickets - 1\n        });\n\n        _this2.ticketsSubject.next(updatedTickets);\n\n        return true;\n      }\n\n      return false;\n    })();\n  }\n\n  addTickets(userId, normalTickets, premiumTickets) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const docRef = doc(_this3.db, 'users', userId); // Check if user document exists; if not, create it with initial amounts\n\n      const docSnap = yield getDoc(docRef);\n\n      if (!docSnap.exists()) {\n        yield setDoc(docRef, {\n          normalTickets: normalTickets || 0,\n          premiumTickets: premiumTickets || 0\n        });\n        return;\n      }\n\n      yield updateDoc(docRef, {\n        normalTickets: increment(normalTickets),\n        premiumTickets: increment(premiumTickets)\n      }); // Não atualizar o subject aqui para evitar bug visual na navbar do admin\n    })();\n  } // Método para forçar atualização dos tickets\n\n\n  refreshTickets(userId) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.getUserTickets(userId);\n    })();\n  }\n\n}\n\nTicketService.ɵfac = function TicketService_Factory(t) {\n  return new (t || TicketService)();\n};\n\nTicketService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TicketService,\n  factory: TicketService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/ticket.service.ts"],"names":["getFirestore","doc","getDoc","setDoc","updateDoc","increment","BehaviorSubject","i0","TicketService","constructor","db","ticketsSubject","normalTickets","premiumTickets","tickets$","asObservable","getUserTickets","userId","docRef","docSnap","exists","data","tickets","next","defaultTickets","useTicket","type","updatedTickets","Object","assign","addTickets","refreshTickets","ɵfac","TicketService_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { getFirestore, doc, getDoc, setDoc, updateDoc, increment } from 'firebase/firestore';\r\nimport { BehaviorSubject } from 'rxjs';\r\nimport * as i0 from \"@angular/core\";\r\nexport class TicketService {\r\n    constructor() {\r\n        this.db = getFirestore();\r\n        this.ticketsSubject = new BehaviorSubject({ normalTickets: 0, premiumTickets: 0 });\r\n        this.tickets$ = this.ticketsSubject.asObservable();\r\n    }\r\n    async getUserTickets(userId) {\r\n        const docRef = doc(this.db, 'users', userId);\r\n        const docSnap = await getDoc(docRef);\r\n        if (docSnap.exists()) {\r\n            const data = docSnap.data();\r\n            const tickets = {\r\n                normalTickets: data.normalTickets || 0,\r\n                premiumTickets: data.premiumTickets || 0\r\n            };\r\n            this.ticketsSubject.next(tickets);\r\n            return tickets;\r\n        }\r\n        const defaultTickets = { normalTickets: 0, premiumTickets: 0 };\r\n        this.ticketsSubject.next(defaultTickets);\r\n        return defaultTickets;\r\n    }\r\n    async useTicket(userId, type) {\r\n        const tickets = await this.getUserTickets(userId);\r\n        const docRef = doc(this.db, 'users', userId);\r\n        if (type === 'NORMAL' && tickets.normalTickets > 0) {\r\n            await updateDoc(docRef, {\r\n                normalTickets: increment(-1)\r\n            });\r\n            // Atualizar o subject após usar ticket\r\n            const updatedTickets = Object.assign(Object.assign({}, tickets), { normalTickets: tickets.normalTickets - 1 });\r\n            this.ticketsSubject.next(updatedTickets);\r\n            return true;\r\n        }\r\n        else if (type === 'PREMIUM' && tickets.premiumTickets > 0) {\r\n            await updateDoc(docRef, {\r\n                premiumTickets: increment(-1)\r\n            });\r\n            // Atualizar o subject após usar ticket\r\n            const updatedTickets = Object.assign(Object.assign({}, tickets), { premiumTickets: tickets.premiumTickets - 1 });\r\n            this.ticketsSubject.next(updatedTickets);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    async addTickets(userId, normalTickets, premiumTickets) {\r\n        const docRef = doc(this.db, 'users', userId);\r\n        // Check if user document exists; if not, create it with initial amounts\r\n        const docSnap = await getDoc(docRef);\r\n        if (!docSnap.exists()) {\r\n            await setDoc(docRef, {\r\n                normalTickets: normalTickets || 0,\r\n                premiumTickets: premiumTickets || 0\r\n            });\r\n            return;\r\n        }\r\n        await updateDoc(docRef, {\r\n            normalTickets: increment(normalTickets),\r\n            premiumTickets: increment(premiumTickets)\r\n        });\r\n        // Não atualizar o subject aqui para evitar bug visual na navbar do admin\r\n    }\r\n    // Método para forçar atualização dos tickets\r\n    async refreshTickets(userId) {\r\n        await this.getUserTickets(userId);\r\n    }\r\n}\r\nTicketService.ɵfac = function TicketService_Factory(t) { return new (t || TicketService)(); };\r\nTicketService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TicketService, factory: TicketService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}