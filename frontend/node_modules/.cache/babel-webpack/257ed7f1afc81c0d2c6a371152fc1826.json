{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { collection, getDocs } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./user.service\";\nimport * as i2 from \"./item.service\";\nexport let RankingService = /*#__PURE__*/(() => {\n  class RankingService {\n    constructor(userService, itemService) {\n      this.userService = userService;\n      this.itemService = itemService;\n    }\n\n    getGlobalRanking() {\n      var _this = this;\n\n      return _asyncToGenerator(function* (limitCount = 50) {\n        try {\n          // Buscar todos os usuários\n          const usersSnapshot = yield getDocs(collection(db, 'users'));\n          const users = usersSnapshot.docs.map(doc => Object.assign({\n            id: doc.id\n          }, doc.data()));\n          const rankingEntries = [];\n\n          for (const user of users) {\n            if (!user.id) continue;\n            const userItems = yield _this.itemService.getUserItems(user.id);\n            if (userItems.length === 0) continue; // Calcular score baseado nos pontos dos itens\n\n            let totalScore = 0;\n            userItems.forEach(ui => {\n              // Calcular pontos totais do item (pontos * quantidade)\n              const itemPoints = (ui.item.points || 0) * ui.quantity;\n              totalScore += itemPoints;\n            }); // Encontrar o item com mais pontos de nível de raridade\n\n            let rarestItem = userItems[0];\n            let maxRarityScore = 0;\n            userItems.forEach(ui => {\n              // Calcular score baseado na raridade e rarityLevel\n              let rarityScore = ui.item.points || 0; // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\n\n              if ((ui.item.rarity === 'LENDARIO' || ui.item.rarity === 'MITICO') && ui.rarityLevel) {\n                const rarityMultiplier = 1 + (1000 - ui.rarityLevel) / 1000; // 1.0 a 2.0\n\n                rarityScore = rarityScore * rarityMultiplier;\n              }\n\n              if (rarityScore > maxRarityScore) {\n                maxRarityScore = rarityScore;\n                rarestItem = ui;\n              }\n            });\n            rankingEntries.push({\n              userId: user.id || '',\n              username: user.username || 'Jogador',\n              photoURL: user.profileIcon || user.photoURL || '',\n              profileBackground: user.profileBackground || '',\n              rarestItem: rarestItem,\n              totalItems: userItems.length,\n              score: totalScore\n            });\n          } // Ordenar por score\n\n\n          rankingEntries.sort((a, b) => b.score - a.score);\n          return rankingEntries.slice(0, limitCount);\n        } catch (error) {\n          console.error('Erro ao buscar ranking:', error);\n          return [];\n        }\n      }).apply(this, arguments);\n    }\n\n    getRankingByBox(_x) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* (boxId, limitCount = 20) {\n        try {\n          const usersSnapshot = yield getDocs(collection(db, 'users'));\n          const users = usersSnapshot.docs.map(doc => Object.assign({\n            id: doc.id\n          }, doc.data()));\n          const rankingEntries = [];\n\n          for (const user of users) {\n            if (!user.id) continue;\n            const rarestItem = yield _this2.itemService.getUserRarestItemInBox(user.id, boxId);\n            if (!rarestItem) continue;\n            let score = (rarestItem.item.points || 0) + rarestItem.item.power; // Para itens lendários e míticos, multiplicar pelo rarityLevel\n\n            if ((rarestItem.item.rarity === 'LENDARIO' || rarestItem.item.rarity === 'MITICO') && rarestItem.rarityLevel) {\n              const rarityMultiplier = 1 + (1000 - rarestItem.rarityLevel) / 1000; // 1.0 a 2.0\n\n              score = score * rarityMultiplier;\n            } // contar quantos itens o usuário tem nessa caixa\n\n\n            const userItems = yield _this2.itemService.getUserItems(user.id);\n            const itemsInBox = userItems.filter(ui => ui.item.boxId === boxId);\n            const totalItemsInBox = itemsInBox.length;\n            rankingEntries.push({\n              userId: user.id || '',\n              username: user.username || 'Jogador',\n              photoURL: user.profileIcon || user.photoURL || '',\n              profileBackground: user.profileBackground || '',\n              rarestItem: rarestItem,\n              totalItems: totalItemsInBox,\n              score\n            });\n          }\n\n          rankingEntries.sort((a, b) => b.score - a.score);\n          return rankingEntries.slice(0, limitCount);\n        } catch (error) {\n          console.error('Erro ao buscar ranking por caixa:', error);\n          return [];\n        }\n      }).apply(this, arguments);\n    }\n\n  }\n\n  RankingService.ɵfac = function RankingService_Factory(t) {\n    return new (t || RankingService)(i0.ɵɵinject(i1.UserService), i0.ɵɵinject(i2.ItemService));\n  };\n\n  RankingService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: RankingService,\n    factory: RankingService.ɵfac,\n    providedIn: 'root'\n  });\n  return RankingService;\n})();","map":null,"metadata":{},"sourceType":"module"}