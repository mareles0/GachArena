{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class MissionService {\n  constructor(http) {\n    this.http = http;\n  } // CRUD Missões\n\n\n  createMission(mission) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const response = yield _this.http.post(`${environment.backendUrl}/missions`, mission).toPromise();\n        return response.id;\n      } catch (error) {\n        console.error('Erro ao criar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n  getMission(id) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const mission = yield _this2.http.get(`${environment.backendUrl}/missions/${id}`).toPromise();\n        return mission || null;\n      } catch (error) {\n        console.error('Erro ao buscar missão:', error);\n        return null;\n      }\n    })();\n  }\n\n  getAllMissions() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const missions = yield _this3.http.get(`${environment.backendUrl}/missions`).toPromise();\n        return missions || [];\n      } catch (error) {\n        console.error('Erro ao buscar missões:', error);\n        return [];\n      }\n    })();\n  }\n\n  getActiveMissions() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const missions = yield _this4.http.get(`${environment.backendUrl}/missions/active`).toPromise();\n        return missions || [];\n      } catch (error) {\n        console.error('Erro ao buscar missões ativas:', error);\n        return [];\n      }\n    })();\n  }\n\n  updateMission(id, mission) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\n          console.error('Invalid mission id provided to updateMission:', id);\n          throw new Error('Invalid mission id provided to updateMission');\n        }\n\n        yield _this5.http.put(`${environment.backendUrl}/missions/${id}`, mission).toPromise();\n      } catch (error) {\n        console.error('Erro ao atualizar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n  deleteMission(id) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\n          console.error('Invalid mission id provided to deleteMission:', id);\n          throw new Error('Invalid mission id provided to deleteMission');\n        }\n\n        yield _this6.http.delete(`${environment.backendUrl}/missions/${id}`).toPromise();\n      } catch (error) {\n        console.error('Erro ao deletar missão:', error);\n        throw error;\n      }\n    })();\n  } // UserMissions\n\n\n  getUserMissions(userId) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const userMissions = yield _this7.http.get(`${environment.backendUrl}/missions/user/${userId}`).toPromise();\n        return userMissions || [];\n      } catch (error) {\n        console.error('Erro ao buscar missões do usuário:', error);\n        return [];\n      }\n    })();\n  }\n\n  startMission(userId, missionId) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // Verificar se já existe\n        const q = query(collection(db, 'userMissions'), where('userId', '==', userId), where('missionId', '==', missionId));\n        const existing = yield getDocs(q);\n\n        if (!existing.empty) {\n          return existing.docs[0].id;\n        } // Fetch mission to determine if it should auto-complete (e.g., DAILY with no requirement)\n\n\n        const mission = yield _this8.getMission(missionId);\n        const isAutoComplete = mission && mission.type === 'DAILY' && (mission.autoComplete === true || !mission.requirement || mission.requirement.trim() === '');\n        const payload = {\n          userId,\n          missionId,\n          progress: isAutoComplete ? 100 : 0,\n          completed: isAutoComplete ? true : false,\n          claimed: isAutoComplete ? true : false,\n          claimedDays: [],\n          // nextAvailableAt allows first day to be collectible immediately if not autoComplete\n          nextAvailableAt: isAutoComplete ? undefined : Timestamp.now(),\n          createdAt: Timestamp.now()\n        };\n\n        if (isAutoComplete) {\n          payload.completedAt = Timestamp.now();\n        }\n\n        const docRef = yield addDoc(collection(db, 'userMissions'), payload);\n        return docRef.id;\n      } catch (error) {\n        console.error('Erro ao iniciar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n  claimMission(userMissionId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'userMissions', userMissionId);\n        yield updateDoc(docRef, {\n          claimed: true,\n          claimedAt: Timestamp.now()\n        });\n      } catch (error) {\n        console.error('Erro ao marcar missão como coletada:', error);\n        throw error;\n      }\n    })();\n  }\n\n  claimDaily(userMissionId, day) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const userMissionRef = doc(db, 'userMissions', userMissionId);\n        yield runTransaction(db, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (tx) {\n            const umSnap = yield tx.get(userMissionRef);\n            if (!umSnap.exists()) throw new Error('UserMission não encontrado');\n            const umData = umSnap.data();\n            const missionId = umData.missionId;\n            const mission = yield _this9.getMission(missionId || '');\n            const totalDays = mission && mission.dailyRewards && mission.dailyRewards.length || 7;\n            const claimedDays = (umData.claimedDays || []).slice();\n            if (claimedDays.includes(day)) throw new Error('Dia já coletado'); // ensure day is the next available unclaimed day (sequential rule)\n\n            const allDays = Array.from({\n              length: totalDays\n            }, (_, i) => i + 1);\n            const nextUnclaimed = allDays.find(d => !claimedDays.includes(d));\n            if (nextUnclaimed !== day) throw new Error('Dia não disponível para coleta'); // check time-based availability\n\n            const nextAvailableTs = umData.nextAvailableAt;\n\n            if (nextAvailableTs) {\n              const nextAvailableMillis = nextAvailableTs.seconds ? nextAvailableTs.seconds * 1000 : nextAvailableTs.toMillis();\n              if (Date.now() < nextAvailableMillis) throw new Error('Dia ainda não disponível');\n            }\n\n            claimedDays.push(day);\n            const progress = Math.round(claimedDays.length / totalDays * 100);\n            const updates = {\n              claimedDays,\n              progress\n            };\n\n            if (claimedDays.length === totalDays) {\n              updates.completed = true;\n              updates.completedAt = Timestamp.now();\n              updates.claimed = true;\n              updates.claimedAt = Timestamp.now();\n              updates.nextAvailableAt = undefined;\n            } else {\n              // set next available to +24h\n              updates.nextAvailableAt = Timestamp.fromMillis(Date.now() + 24 * 60 * 60 * 1000);\n            }\n\n            tx.update(userMissionRef, updates);\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      } catch (error) {\n        console.error('Erro ao coletar dia:', error);\n        throw error;\n      }\n    })();\n  }\n\n  updateProgress(userMissionId, progress) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'userMissions', userMissionId);\n        yield updateDoc(docRef, {\n          progress\n        });\n      } catch (error) {\n        console.error('Erro ao atualizar progresso:', error);\n        throw error;\n      }\n    })();\n  }\n\n  completeMission(userMissionId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'userMissions', userMissionId);\n        yield updateDoc(docRef, {\n          completed: true,\n          completedAt: Timestamp.now()\n        });\n      } catch (error) {\n        console.error('Erro ao completar missão:', error);\n        throw error;\n      }\n    })();\n  }\n\n}\n\nMissionService.ɵfac = function MissionService_Factory(t) {\n  return new (t || MissionService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nMissionService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: MissionService,\n  factory: MissionService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/mission.service.ts"],"names":["environment","i0","i1","MissionService","constructor","http","createMission","mission","response","post","backendUrl","toPromise","id","error","console","getMission","get","getAllMissions","missions","getActiveMissions","updateMission","trim","includes","Error","put","deleteMission","delete","getUserMissions","userId","userMissions","startMission","missionId","q","query","collection","db","where","existing","getDocs","empty","docs","isAutoComplete","type","autoComplete","requirement","payload","progress","completed","claimed","claimedDays","nextAvailableAt","undefined","Timestamp","now","createdAt","completedAt","docRef","addDoc","claimMission","userMissionId","doc","updateDoc","claimedAt","claimDaily","day","userMissionRef","runTransaction","tx","umSnap","exists","umData","data","totalDays","dailyRewards","length","slice","allDays","Array","from","_","i","nextUnclaimed","find","d","nextAvailableTs","nextAvailableMillis","seconds","toMillis","Date","push","Math","round","updates","fromMillis","update","updateProgress","completeMission","ɵfac","MissionService_Factory","t","ɵɵinject","HttpClient","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { environment } from '../../environments/environment';\r\nimport * as i0 from \"@angular/core\";\r\nimport * as i1 from \"@angular/common/http\";\r\nexport class MissionService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    // CRUD Missões\r\n    async createMission(mission) {\r\n        try {\r\n            const response = await this.http.post(`${environment.backendUrl}/missions`, mission).toPromise();\r\n            return response.id;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao criar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async getMission(id) {\r\n        try {\r\n            const mission = await this.http.get(`${environment.backendUrl}/missions/${id}`).toPromise();\r\n            return mission || null;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missão:', error);\r\n            return null;\r\n        }\r\n    }\r\n    async getAllMissions() {\r\n        try {\r\n            const missions = await this.http.get(`${environment.backendUrl}/missions`).toPromise();\r\n            return missions || [];\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missões:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async getActiveMissions() {\r\n        try {\r\n            const missions = await this.http.get(`${environment.backendUrl}/missions/active`).toPromise();\r\n            return missions || [];\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missões ativas:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async updateMission(id, mission) {\r\n        try {\r\n            if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\r\n                console.error('Invalid mission id provided to updateMission:', id);\r\n                throw new Error('Invalid mission id provided to updateMission');\r\n            }\r\n            await this.http.put(`${environment.backendUrl}/missions/${id}`, mission).toPromise();\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao atualizar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async deleteMission(id) {\r\n        try {\r\n            if (!id || typeof id !== 'string' || id.trim() === '' || id.includes('/')) {\r\n                console.error('Invalid mission id provided to deleteMission:', id);\r\n                throw new Error('Invalid mission id provided to deleteMission');\r\n            }\r\n            await this.http.delete(`${environment.backendUrl}/missions/${id}`).toPromise();\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao deletar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    // UserMissions\r\n    async getUserMissions(userId) {\r\n        try {\r\n            const userMissions = await this.http.get(`${environment.backendUrl}/missions/user/${userId}`).toPromise();\r\n            return userMissions || [];\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar missões do usuário:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async startMission(userId, missionId) {\r\n        try {\r\n            // Verificar se já existe\r\n            const q = query(collection(db, 'userMissions'), where('userId', '==', userId), where('missionId', '==', missionId));\r\n            const existing = await getDocs(q);\r\n            if (!existing.empty) {\r\n                return existing.docs[0].id;\r\n            }\r\n            // Fetch mission to determine if it should auto-complete (e.g., DAILY with no requirement)\r\n            const mission = await this.getMission(missionId);\r\n            const isAutoComplete = mission && mission.type === 'DAILY' && (mission.autoComplete === true || !mission.requirement || mission.requirement.trim() === '');\r\n            const payload = {\r\n                userId,\r\n                missionId,\r\n                progress: isAutoComplete ? 100 : 0,\r\n                completed: isAutoComplete ? true : false,\r\n                claimed: isAutoComplete ? true : false,\r\n                claimedDays: [],\r\n                // nextAvailableAt allows first day to be collectible immediately if not autoComplete\r\n                nextAvailableAt: isAutoComplete ? undefined : Timestamp.now(),\r\n                createdAt: Timestamp.now()\r\n            };\r\n            if (isAutoComplete) {\r\n                payload.completedAt = Timestamp.now();\r\n            }\r\n            const docRef = await addDoc(collection(db, 'userMissions'), payload);\r\n            return docRef.id;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao iniciar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async claimMission(userMissionId) {\r\n        try {\r\n            const docRef = doc(db, 'userMissions', userMissionId);\r\n            await updateDoc(docRef, { claimed: true, claimedAt: Timestamp.now() });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao marcar missão como coletada:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async claimDaily(userMissionId, day) {\r\n        try {\r\n            const userMissionRef = doc(db, 'userMissions', userMissionId);\r\n            await runTransaction(db, async (tx) => {\r\n                const umSnap = await tx.get(userMissionRef);\r\n                if (!umSnap.exists())\r\n                    throw new Error('UserMission não encontrado');\r\n                const umData = umSnap.data();\r\n                const missionId = umData.missionId;\r\n                const mission = await this.getMission(missionId || '');\r\n                const totalDays = (mission && mission.dailyRewards && mission.dailyRewards.length) || 7;\r\n                const claimedDays = (umData.claimedDays || []).slice();\r\n                if (claimedDays.includes(day))\r\n                    throw new Error('Dia já coletado');\r\n                // ensure day is the next available unclaimed day (sequential rule)\r\n                const allDays = Array.from({ length: totalDays }, (_, i) => i + 1);\r\n                const nextUnclaimed = allDays.find(d => !claimedDays.includes(d));\r\n                if (nextUnclaimed !== day)\r\n                    throw new Error('Dia não disponível para coleta');\r\n                // check time-based availability\r\n                const nextAvailableTs = umData.nextAvailableAt;\r\n                if (nextAvailableTs) {\r\n                    const nextAvailableMillis = (nextAvailableTs.seconds ? nextAvailableTs.seconds * 1000 : nextAvailableTs.toMillis());\r\n                    if (Date.now() < nextAvailableMillis)\r\n                        throw new Error('Dia ainda não disponível');\r\n                }\r\n                claimedDays.push(day);\r\n                const progress = Math.round((claimedDays.length / totalDays) * 100);\r\n                const updates = { claimedDays, progress };\r\n                if (claimedDays.length === totalDays) {\r\n                    updates.completed = true;\r\n                    updates.completedAt = Timestamp.now();\r\n                    updates.claimed = true;\r\n                    updates.claimedAt = Timestamp.now();\r\n                    updates.nextAvailableAt = undefined;\r\n                }\r\n                else {\r\n                    // set next available to +24h\r\n                    updates.nextAvailableAt = Timestamp.fromMillis(Date.now() + 24 * 60 * 60 * 1000);\r\n                }\r\n                tx.update(userMissionRef, updates);\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao coletar dia:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async updateProgress(userMissionId, progress) {\r\n        try {\r\n            const docRef = doc(db, 'userMissions', userMissionId);\r\n            await updateDoc(docRef, { progress });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao atualizar progresso:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async completeMission(userMissionId) {\r\n        try {\r\n            const docRef = doc(db, 'userMissions', userMissionId);\r\n            await updateDoc(docRef, {\r\n                completed: true,\r\n                completedAt: Timestamp.now()\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao completar missão:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nMissionService.ɵfac = function MissionService_Factory(t) { return new (t || MissionService)(i0.ɵɵinject(i1.HttpClient)); };\r\nMissionService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MissionService, factory: MissionService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}