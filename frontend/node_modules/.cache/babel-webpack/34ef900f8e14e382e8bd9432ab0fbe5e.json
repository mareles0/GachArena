{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./user.service\";\nimport * as i3 from \"./item.service\";\nexport class RankingService {\n  constructor(http, userService, itemService) {\n    this.http = http;\n    this.userService = userService;\n    this.itemService = itemService;\n  }\n\n  getGlobalRanking() {\n    var _this = this;\n\n    return _asyncToGenerator(function* (limitCount = 50) {\n      try {\n        // Buscar todos os usuários\n        const usersSnapshot = yield getDocs(collection(db, 'users'));\n        const users = usersSnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data()));\n        const rankingEntries = [];\n\n        for (const user of users) {\n          if (!user.id) continue;\n          const userItems = yield _this.itemService.getUserItems(user.id);\n          if (userItems.length === 0) continue; // Calcular score baseado nos pontos dos itens\n\n          let totalScore = 0;\n          userItems.forEach(ui => {\n            // Calcular pontos totais do item (pontos * quantidade)\n            const itemPoints = (ui.item.points || 0) * ui.quantity;\n            totalScore += itemPoints;\n          }); // Encontrar o item com mais pontos de nível de raridade\n\n          let rarestItem = userItems[0];\n          let maxRarityScore = 0;\n          userItems.forEach(ui => {\n            // Calcular score baseado na raridade e rarityLevel\n            let rarityScore = ui.item.points || 0; // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\n\n            if ((ui.item.rarity === 'LENDARIO' || ui.item.rarity === 'MITICO') && ui.rarityLevel) {\n              const rarityMultiplier = 1 + (1000 - ui.rarityLevel) / 1000; // 1.0 a 2.0\n\n              rarityScore = rarityScore * rarityMultiplier;\n            }\n\n            if (rarityScore > maxRarityScore) {\n              maxRarityScore = rarityScore;\n              rarestItem = ui;\n            }\n          });\n          rankingEntries.push({\n            userId: user.id || '',\n            username: user.username || 'Jogador',\n            photoURL: user.profileIcon || user.photoURL || '',\n            profileBackground: user.profileBackground || '',\n            rarestItem: rarestItem,\n            totalItems: userItems.length,\n            score: totalScore\n          });\n        } // Ordenar por score\n\n\n        rankingEntries.sort((a, b) => b.score - a.score);\n        return rankingEntries.slice(0, limitCount);\n      } catch (error) {\n        console.error('Erro ao buscar ranking:', error);\n        return [];\n      }\n    }).apply(this, arguments);\n  }\n\n  getRankingByBox(_x) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* (boxId, limitCount = 20) {\n      try {\n        const usersSnapshot = yield getDocs(collection(db, 'users'));\n        const users = usersSnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data()));\n        const rankingEntries = [];\n\n        for (const user of users) {\n          if (!user.id) continue;\n          const rarestItem = yield _this2.itemService.getUserRarestItemInBox(user.id, boxId);\n          if (!rarestItem) continue;\n          let score = (rarestItem.item.points || 0) + rarestItem.item.power; // Para itens lendários e míticos, multiplicar pelo rarityLevel\n\n          if ((rarestItem.item.rarity === 'LENDARIO' || rarestItem.item.rarity === 'MITICO') && rarestItem.rarityLevel) {\n            const rarityMultiplier = 1 + (1000 - rarestItem.rarityLevel) / 1000; // 1.0 a 2.0\n\n            score = score * rarityMultiplier;\n          } // contar quantos itens o usuário tem nessa caixa\n\n\n          const userItems = yield _this2.itemService.getUserItems(user.id);\n          const itemsInBox = userItems.filter(ui => ui.item.boxId === boxId);\n          const totalItemsInBox = itemsInBox.length;\n          rankingEntries.push({\n            userId: user.id || '',\n            username: user.username || 'Jogador',\n            photoURL: user.profileIcon || user.photoURL || '',\n            profileBackground: user.profileBackground || '',\n            rarestItem: rarestItem,\n            totalItems: totalItemsInBox,\n            score\n          });\n        }\n\n        rankingEntries.sort((a, b) => b.score - a.score);\n        return rankingEntries.slice(0, limitCount);\n      } catch (error) {\n        console.error('Erro ao buscar ranking por caixa:', error);\n        return [];\n      }\n    }).apply(this, arguments);\n  }\n\n}\n\nRankingService.ɵfac = function RankingService_Factory(t) {\n  return new (t || RankingService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService), i0.ɵɵinject(i3.ItemService));\n};\n\nRankingService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: RankingService,\n  factory: RankingService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/ranking.service.ts"],"names":["i0","i1","i2","i3","RankingService","constructor","http","userService","itemService","getGlobalRanking","limitCount","usersSnapshot","getDocs","collection","db","users","docs","map","doc","Object","assign","id","data","rankingEntries","user","userItems","getUserItems","length","totalScore","forEach","ui","itemPoints","item","points","quantity","rarestItem","maxRarityScore","rarityScore","rarity","rarityLevel","rarityMultiplier","push","userId","username","photoURL","profileIcon","profileBackground","totalItems","score","sort","a","b","slice","error","console","getRankingByBox","boxId","getUserRarestItemInBox","power","itemsInBox","filter","totalItemsInBox","ɵfac","RankingService_Factory","t","ɵɵinject","HttpClient","UserService","ItemService","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import * as i0 from \"@angular/core\";\r\nimport * as i1 from \"@angular/common/http\";\r\nimport * as i2 from \"./user.service\";\r\nimport * as i3 from \"./item.service\";\r\nexport class RankingService {\r\n    constructor(http, userService, itemService) {\r\n        this.http = http;\r\n        this.userService = userService;\r\n        this.itemService = itemService;\r\n    }\r\n    async getGlobalRanking(limitCount = 50) {\r\n        try {\r\n            // Buscar todos os usuários\r\n            const usersSnapshot = await getDocs(collection(db, 'users'));\r\n            const users = usersSnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n            const rankingEntries = [];\r\n            for (const user of users) {\r\n                if (!user.id)\r\n                    continue;\r\n                const userItems = await this.itemService.getUserItems(user.id);\r\n                if (userItems.length === 0)\r\n                    continue;\r\n                // Calcular score baseado nos pontos dos itens\r\n                let totalScore = 0;\r\n                userItems.forEach(ui => {\r\n                    // Calcular pontos totais do item (pontos * quantidade)\r\n                    const itemPoints = (ui.item.points || 0) * ui.quantity;\r\n                    totalScore += itemPoints;\r\n                });\r\n                // Encontrar o item com mais pontos de nível de raridade\r\n                let rarestItem = userItems[0];\r\n                let maxRarityScore = 0;\r\n                userItems.forEach(ui => {\r\n                    // Calcular score baseado na raridade e rarityLevel\r\n                    let rarityScore = ui.item.points || 0;\r\n                    // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\r\n                    if ((ui.item.rarity === 'LENDARIO' || ui.item.rarity === 'MITICO') && ui.rarityLevel) {\r\n                        const rarityMultiplier = 1 + ((1000 - ui.rarityLevel) / 1000); // 1.0 a 2.0\r\n                        rarityScore = rarityScore * rarityMultiplier;\r\n                    }\r\n                    if (rarityScore > maxRarityScore) {\r\n                        maxRarityScore = rarityScore;\r\n                        rarestItem = ui;\r\n                    }\r\n                });\r\n                rankingEntries.push({\r\n                    userId: user.id || '',\r\n                    username: user.username || 'Jogador',\r\n                    photoURL: user.profileIcon || user.photoURL || '',\r\n                    profileBackground: user.profileBackground || '',\r\n                    rarestItem: rarestItem,\r\n                    totalItems: userItems.length,\r\n                    score: totalScore\r\n                });\r\n            }\r\n            // Ordenar por score\r\n            rankingEntries.sort((a, b) => b.score - a.score);\r\n            return rankingEntries.slice(0, limitCount);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar ranking:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async getRankingByBox(boxId, limitCount = 20) {\r\n        try {\r\n            const usersSnapshot = await getDocs(collection(db, 'users'));\r\n            const users = usersSnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n            const rankingEntries = [];\r\n            for (const user of users) {\r\n                if (!user.id)\r\n                    continue;\r\n                const rarestItem = await this.itemService.getUserRarestItemInBox(user.id, boxId);\r\n                if (!rarestItem)\r\n                    continue;\r\n                let score = (rarestItem.item.points || 0) + rarestItem.item.power;\r\n                // Para itens lendários e míticos, multiplicar pelo rarityLevel\r\n                if ((rarestItem.item.rarity === 'LENDARIO' || rarestItem.item.rarity === 'MITICO') && rarestItem.rarityLevel) {\r\n                    const rarityMultiplier = 1 + ((1000 - rarestItem.rarityLevel) / 1000); // 1.0 a 2.0\r\n                    score = score * rarityMultiplier;\r\n                }\r\n                // contar quantos itens o usuário tem nessa caixa\r\n                const userItems = await this.itemService.getUserItems(user.id);\r\n                const itemsInBox = userItems.filter((ui) => ui.item.boxId === boxId);\r\n                const totalItemsInBox = itemsInBox.length;\r\n                rankingEntries.push({\r\n                    userId: user.id || '',\r\n                    username: user.username || 'Jogador',\r\n                    photoURL: user.profileIcon || user.photoURL || '',\r\n                    profileBackground: user.profileBackground || '',\r\n                    rarestItem: rarestItem,\r\n                    totalItems: totalItemsInBox,\r\n                    score\r\n                });\r\n            }\r\n            rankingEntries.sort((a, b) => b.score - a.score);\r\n            return rankingEntries.slice(0, limitCount);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar ranking por caixa:', error);\r\n            return [];\r\n        }\r\n    }\r\n}\r\nRankingService.ɵfac = function RankingService_Factory(t) { return new (t || RankingService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService), i0.ɵɵinject(i3.ItemService)); };\r\nRankingService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: RankingService, factory: RankingService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}