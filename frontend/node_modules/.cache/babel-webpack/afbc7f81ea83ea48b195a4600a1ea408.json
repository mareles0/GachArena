{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { collection, doc, getDocs, addDoc, updateDoc, deleteDoc, query, where, Timestamp } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nexport class FriendService {\n  constructor() {}\n\n  sendFriendRequest(fromUserId, toUserId, fromUserName, toUserName, fromUserPhoto) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        // Verificar se já existe uma solicitação pendente\n        const q = query(collection(db, 'friends'), where('userId', '==', fromUserId), where('friendId', '==', toUserId), where('status', '==', 'PENDING'));\n        const existing = yield getDocs(q);\n\n        if (!existing.empty) {\n          throw new Error('Já existe uma solicitação pendente');\n        } // Verificar se já são amigos\n\n\n        const friendshipCheck = yield _this.areFriends(fromUserId, toUserId);\n\n        if (friendshipCheck) {\n          throw new Error('Vocês já são amigos');\n        } // construir payload sem campos undefined (Firestore não aceita `undefined`)\n\n\n        const payload = {\n          userId: fromUserId,\n          friendId: toUserId,\n          friendUsername: toUserName,\n          status: 'PENDING',\n          createdAt: Timestamp.now()\n        };\n\n        if (typeof fromUserPhoto !== 'undefined' && fromUserPhoto !== null && fromUserPhoto !== '') {\n          payload.friendPhotoURL = fromUserPhoto;\n        }\n\n        const docRef = yield addDoc(collection(db, 'friends'), payload);\n        return docRef.id;\n      } catch (error) {\n        console.error('Erro ao enviar solicitação de amizade:', error);\n        throw error;\n      }\n    })();\n  }\n\n  getPendingRequests(userId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const q = query(collection(db, 'friends'), where('friendId', '==', userId), where('status', '==', 'PENDING'));\n        const querySnapshot = yield getDocs(q);\n        return querySnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data()));\n      } catch (error) {\n        console.error('Erro ao buscar solicitações pendentes:', error);\n        return [];\n      }\n    })();\n  }\n\n  acceptFriendRequest(requestId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'friends', requestId);\n        yield updateDoc(docRef, {\n          status: 'ACCEPTED'\n        });\n      } catch (error) {\n        console.error('Erro ao aceitar solicitação:', error);\n        throw error;\n      }\n    })();\n  }\n\n  rejectFriendRequest(requestId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'friends', requestId);\n        yield updateDoc(docRef, {\n          status: 'REJECTED'\n        });\n      } catch (error) {\n        console.error('Erro ao rejeitar solicitação:', error);\n        throw error;\n      }\n    })();\n  }\n\n  getFriends(userId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const q = query(collection(db, 'friends'), where('status', '==', 'ACCEPTED'));\n        const querySnapshot = yield getDocs(q);\n        const allFriends = querySnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data())); // Filtrar amigos do usuário (pode estar em userId ou friendId)\n\n        return allFriends.filter(friend => friend.userId === userId || friend.friendId === userId);\n      } catch (error) {\n        console.error('Erro ao buscar amigos:', error);\n        return [];\n      }\n    })();\n  }\n\n  removeFriend(friendshipId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const docRef = doc(db, 'friends', friendshipId);\n        yield deleteDoc(docRef);\n      } catch (error) {\n        console.error('Erro ao remover amigo:', error);\n        throw error;\n      }\n    })();\n  }\n\n  areFriends(user1Id, user2Id) {\n    return _asyncToGenerator(function* () {\n      try {\n        const q = query(collection(db, 'friends'), where('status', '==', 'ACCEPTED'));\n        const querySnapshot = yield getDocs(q);\n        const friendships = querySnapshot.docs.map(doc => doc.data());\n        return friendships.some(f => f.userId === user1Id && f.friendId === user2Id || f.userId === user2Id && f.friendId === user1Id);\n      } catch (error) {\n        console.error('Erro ao verificar amizade:', error);\n        return false;\n      }\n    })();\n  }\n\n  searchUsers(searchTerm, currentUserId) {\n    return _asyncToGenerator(function* () {\n      try {\n        const usersSnapshot = yield getDocs(collection(db, 'users'));\n        const users = usersSnapshot.docs.map(doc => Object.assign({\n          id: doc.id\n        }, doc.data())); // Filtrar usuários que correspondem à busca (exceto o próprio usuário)\n\n        return users.filter(user => user.id !== currentUserId && user.userType === 'PLAYER' && (user.username.toLowerCase().includes(searchTerm.toLowerCase()) || user.email.toLowerCase().includes(searchTerm.toLowerCase())));\n      } catch (error) {\n        console.error('Erro ao buscar usuários:', error);\n        return [];\n      }\n    })();\n  }\n\n}\n\nFriendService.ɵfac = function FriendService_Factory(t) {\n  return new (t || FriendService)();\n};\n\nFriendService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FriendService,\n  factory: FriendService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/friend.service.ts"],"names":["collection","doc","getDocs","addDoc","updateDoc","deleteDoc","query","where","Timestamp","db","i0","FriendService","constructor","sendFriendRequest","fromUserId","toUserId","fromUserName","toUserName","fromUserPhoto","q","existing","empty","Error","friendshipCheck","areFriends","payload","userId","friendId","friendUsername","status","createdAt","now","friendPhotoURL","docRef","id","error","console","getPendingRequests","querySnapshot","docs","map","Object","assign","data","acceptFriendRequest","requestId","rejectFriendRequest","getFriends","allFriends","filter","friend","removeFriend","friendshipId","user1Id","user2Id","friendships","some","f","searchUsers","searchTerm","currentUserId","usersSnapshot","users","user","userType","username","toLowerCase","includes","email","ɵfac","FriendService_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":";AAAA,SAASA,UAAT,EAAqBC,GAArB,EAA0BC,OAA1B,EAAmCC,MAAnC,EAA2CC,SAA3C,EAAsDC,SAAtD,EAAiEC,KAAjE,EAAwEC,KAAxE,EAA+EC,SAA/E,QAAgG,oBAAhG;AACA,SAASC,EAAT,QAAmB,oBAAnB;AACA,OAAO,KAAKC,EAAZ,MAAoB,eAApB;AACA,OAAO,MAAMC,aAAN,CAAoB;AACvBC,EAAAA,WAAW,GAAG,CAAG;;AACXC,EAAAA,iBAAiB,CAACC,UAAD,EAAaC,QAAb,EAAuBC,YAAvB,EAAqCC,UAArC,EAAiDC,aAAjD,EAAgE;AAAA;;AAAA;AACnF,UAAI;AACA;AACA,cAAMC,CAAC,GAAGb,KAAK,CAACN,UAAU,CAACS,EAAD,EAAK,SAAL,CAAX,EAA4BF,KAAK,CAAC,QAAD,EAAW,IAAX,EAAiBO,UAAjB,CAAjC,EAA+DP,KAAK,CAAC,UAAD,EAAa,IAAb,EAAmBQ,QAAnB,CAApE,EAAkGR,KAAK,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,CAAvG,CAAf;AACA,cAAMa,QAAQ,SAASlB,OAAO,CAACiB,CAAD,CAA9B;;AACA,YAAI,CAACC,QAAQ,CAACC,KAAd,EAAqB;AACjB,gBAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACH,SAND,CAOA;;;AACA,cAAMC,eAAe,SAAS,KAAI,CAACC,UAAL,CAAgBV,UAAhB,EAA4BC,QAA5B,CAA9B;;AACA,YAAIQ,eAAJ,EAAqB;AACjB,gBAAM,IAAID,KAAJ,CAAU,qBAAV,CAAN;AACH,SAXD,CAYA;;;AACA,cAAMG,OAAO,GAAG;AACZC,UAAAA,MAAM,EAAEZ,UADI;AAEZa,UAAAA,QAAQ,EAAEZ,QAFE;AAGZa,UAAAA,cAAc,EAAEX,UAHJ;AAIZY,UAAAA,MAAM,EAAE,SAJI;AAKZC,UAAAA,SAAS,EAAEtB,SAAS,CAACuB,GAAV;AALC,SAAhB;;AAOA,YAAI,OAAOb,aAAP,KAAyB,WAAzB,IAAwCA,aAAa,KAAK,IAA1D,IAAkEA,aAAa,KAAK,EAAxF,EAA4F;AACxFO,UAAAA,OAAO,CAACO,cAAR,GAAyBd,aAAzB;AACH;;AACD,cAAMe,MAAM,SAAS9B,MAAM,CAACH,UAAU,CAACS,EAAD,EAAK,SAAL,CAAX,EAA4BgB,OAA5B,CAA3B;AACA,eAAOQ,MAAM,CAACC,EAAd;AACH,OAzBD,CA0BA,OAAOC,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,wCAAd,EAAwDA,KAAxD;AACA,cAAMA,KAAN;AACH;AA9BkF;AA+BtF;;AACKE,EAAAA,kBAAkB,CAACX,MAAD,EAAS;AAAA;AAC7B,UAAI;AACA,cAAMP,CAAC,GAAGb,KAAK,CAACN,UAAU,CAACS,EAAD,EAAK,SAAL,CAAX,EAA4BF,KAAK,CAAC,UAAD,EAAa,IAAb,EAAmBmB,MAAnB,CAAjC,EAA6DnB,KAAK,CAAC,QAAD,EAAW,IAAX,EAAiB,SAAjB,CAAlE,CAAf;AACA,cAAM+B,aAAa,SAASpC,OAAO,CAACiB,CAAD,CAAnC;AACA,eAAOmB,aAAa,CAACC,IAAd,CAAmBC,GAAnB,CAAuBvC,GAAG,IAAKwC,MAAM,CAACC,MAAP,CAAc;AAAER,UAAAA,EAAE,EAAEjC,GAAG,CAACiC;AAAV,SAAd,EAA8BjC,GAAG,CAAC0C,IAAJ,EAA9B,CAA/B,CAAP;AACH,OAJD,CAKA,OAAOR,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,wCAAd,EAAwDA,KAAxD;AACA,eAAO,EAAP;AACH;AAT4B;AAUhC;;AACKS,EAAAA,mBAAmB,CAACC,SAAD,EAAY;AAAA;AACjC,UAAI;AACA,cAAMZ,MAAM,GAAGhC,GAAG,CAACQ,EAAD,EAAK,SAAL,EAAgBoC,SAAhB,CAAlB;AACA,cAAMzC,SAAS,CAAC6B,MAAD,EAAS;AACpBJ,UAAAA,MAAM,EAAE;AADY,SAAT,CAAf;AAGH,OALD,CAMA,OAAOM,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,8BAAd,EAA8CA,KAA9C;AACA,cAAMA,KAAN;AACH;AAVgC;AAWpC;;AACKW,EAAAA,mBAAmB,CAACD,SAAD,EAAY;AAAA;AACjC,UAAI;AACA,cAAMZ,MAAM,GAAGhC,GAAG,CAACQ,EAAD,EAAK,SAAL,EAAgBoC,SAAhB,CAAlB;AACA,cAAMzC,SAAS,CAAC6B,MAAD,EAAS;AACpBJ,UAAAA,MAAM,EAAE;AADY,SAAT,CAAf;AAGH,OALD,CAMA,OAAOM,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,+BAAd,EAA+CA,KAA/C;AACA,cAAMA,KAAN;AACH;AAVgC;AAWpC;;AACKY,EAAAA,UAAU,CAACrB,MAAD,EAAS;AAAA;AACrB,UAAI;AACA,cAAMP,CAAC,GAAGb,KAAK,CAACN,UAAU,CAACS,EAAD,EAAK,SAAL,CAAX,EAA4BF,KAAK,CAAC,QAAD,EAAW,IAAX,EAAiB,UAAjB,CAAjC,CAAf;AACA,cAAM+B,aAAa,SAASpC,OAAO,CAACiB,CAAD,CAAnC;AACA,cAAM6B,UAAU,GAAGV,aAAa,CAACC,IAAd,CAAmBC,GAAnB,CAAuBvC,GAAG,IAAKwC,MAAM,CAACC,MAAP,CAAc;AAAER,UAAAA,EAAE,EAAEjC,GAAG,CAACiC;AAAV,SAAd,EAA8BjC,GAAG,CAAC0C,IAAJ,EAA9B,CAA/B,CAAnB,CAHA,CAIA;;AACA,eAAOK,UAAU,CAACC,MAAX,CAAkBC,MAAM,IAAIA,MAAM,CAACxB,MAAP,KAAkBA,MAAlB,IAA4BwB,MAAM,CAACvB,QAAP,KAAoBD,MAA5E,CAAP;AACH,OAND,CAOA,OAAOS,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,wBAAd,EAAwCA,KAAxC;AACA,eAAO,EAAP;AACH;AAXoB;AAYxB;;AACKgB,EAAAA,YAAY,CAACC,YAAD,EAAe;AAAA;AAC7B,UAAI;AACA,cAAMnB,MAAM,GAAGhC,GAAG,CAACQ,EAAD,EAAK,SAAL,EAAgB2C,YAAhB,CAAlB;AACA,cAAM/C,SAAS,CAAC4B,MAAD,CAAf;AACH,OAHD,CAIA,OAAOE,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,wBAAd,EAAwCA,KAAxC;AACA,cAAMA,KAAN;AACH;AAR4B;AAShC;;AACKX,EAAAA,UAAU,CAAC6B,OAAD,EAAUC,OAAV,EAAmB;AAAA;AAC/B,UAAI;AACA,cAAMnC,CAAC,GAAGb,KAAK,CAACN,UAAU,CAACS,EAAD,EAAK,SAAL,CAAX,EAA4BF,KAAK,CAAC,QAAD,EAAW,IAAX,EAAiB,UAAjB,CAAjC,CAAf;AACA,cAAM+B,aAAa,SAASpC,OAAO,CAACiB,CAAD,CAAnC;AACA,cAAMoC,WAAW,GAAGjB,aAAa,CAACC,IAAd,CAAmBC,GAAnB,CAAuBvC,GAAG,IAAIA,GAAG,CAAC0C,IAAJ,EAA9B,CAApB;AACA,eAAOY,WAAW,CAACC,IAAZ,CAAiBC,CAAC,IAAKA,CAAC,CAAC/B,MAAF,KAAa2B,OAAb,IAAwBI,CAAC,CAAC9B,QAAF,KAAe2B,OAAxC,IACxBG,CAAC,CAAC/B,MAAF,KAAa4B,OAAb,IAAwBG,CAAC,CAAC9B,QAAF,KAAe0B,OADrC,CAAP;AAEH,OAND,CAOA,OAAOlB,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,4BAAd,EAA4CA,KAA5C;AACA,eAAO,KAAP;AACH;AAX8B;AAYlC;;AACKuB,EAAAA,WAAW,CAACC,UAAD,EAAaC,aAAb,EAA4B;AAAA;AACzC,UAAI;AACA,cAAMC,aAAa,SAAS3D,OAAO,CAACF,UAAU,CAACS,EAAD,EAAK,OAAL,CAAX,CAAnC;AACA,cAAMqD,KAAK,GAAGD,aAAa,CAACtB,IAAd,CAAmBC,GAAnB,CAAuBvC,GAAG,IAAKwC,MAAM,CAACC,MAAP,CAAc;AAAER,UAAAA,EAAE,EAAEjC,GAAG,CAACiC;AAAV,SAAd,EAA8BjC,GAAG,CAAC0C,IAAJ,EAA9B,CAA/B,CAAd,CAFA,CAGA;;AACA,eAAOmB,KAAK,CAACb,MAAN,CAAac,IAAI,IAAIA,IAAI,CAAC7B,EAAL,KAAY0B,aAAZ,IACxBG,IAAI,CAACC,QAAL,KAAkB,QADM,KAEvBD,IAAI,CAACE,QAAL,CAAcC,WAAd,GAA4BC,QAA5B,CAAqCR,UAAU,CAACO,WAAX,EAArC,KACGH,IAAI,CAACK,KAAL,CAAWF,WAAX,GAAyBC,QAAzB,CAAkCR,UAAU,CAACO,WAAX,EAAlC,CAHoB,CAArB,CAAP;AAIH,OARD,CASA,OAAO/B,KAAP,EAAc;AACVC,QAAAA,OAAO,CAACD,KAAR,CAAc,0BAAd,EAA0CA,KAA1C;AACA,eAAO,EAAP;AACH;AAbwC;AAc5C;;AAvHsB;;AAyH3BxB,aAAa,CAAC0D,IAAd,GAAqB,SAASC,qBAAT,CAA+BC,CAA/B,EAAkC;AAAE,SAAO,KAAKA,CAAC,IAAI5D,aAAV,GAAP;AAAoC,CAA7F;;AACAA,aAAa,CAAC6D,KAAd,GAAsB,aAAc9D,EAAE,CAAC+D,kBAAH,CAAsB;AAAEC,EAAAA,KAAK,EAAE/D,aAAT;AAAwBgE,EAAAA,OAAO,EAAEhE,aAAa,CAAC0D,IAA/C;AAAqDO,EAAAA,UAAU,EAAE;AAAjE,CAAtB,CAApC","sourcesContent":["import { collection, doc, getDocs, addDoc, updateDoc, deleteDoc, query, where, Timestamp } from 'firebase/firestore';\r\nimport { db } from '../firebase.config';\r\nimport * as i0 from \"@angular/core\";\r\nexport class FriendService {\r\n    constructor() { }\r\n    async sendFriendRequest(fromUserId, toUserId, fromUserName, toUserName, fromUserPhoto) {\r\n        try {\r\n            // Verificar se já existe uma solicitação pendente\r\n            const q = query(collection(db, 'friends'), where('userId', '==', fromUserId), where('friendId', '==', toUserId), where('status', '==', 'PENDING'));\r\n            const existing = await getDocs(q);\r\n            if (!existing.empty) {\r\n                throw new Error('Já existe uma solicitação pendente');\r\n            }\r\n            // Verificar se já são amigos\r\n            const friendshipCheck = await this.areFriends(fromUserId, toUserId);\r\n            if (friendshipCheck) {\r\n                throw new Error('Vocês já são amigos');\r\n            }\r\n            // construir payload sem campos undefined (Firestore não aceita `undefined`)\r\n            const payload = {\r\n                userId: fromUserId,\r\n                friendId: toUserId,\r\n                friendUsername: toUserName,\r\n                status: 'PENDING',\r\n                createdAt: Timestamp.now()\r\n            };\r\n            if (typeof fromUserPhoto !== 'undefined' && fromUserPhoto !== null && fromUserPhoto !== '') {\r\n                payload.friendPhotoURL = fromUserPhoto;\r\n            }\r\n            const docRef = await addDoc(collection(db, 'friends'), payload);\r\n            return docRef.id;\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao enviar solicitação de amizade:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async getPendingRequests(userId) {\r\n        try {\r\n            const q = query(collection(db, 'friends'), where('friendId', '==', userId), where('status', '==', 'PENDING'));\r\n            const querySnapshot = await getDocs(q);\r\n            return querySnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar solicitações pendentes:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async acceptFriendRequest(requestId) {\r\n        try {\r\n            const docRef = doc(db, 'friends', requestId);\r\n            await updateDoc(docRef, {\r\n                status: 'ACCEPTED'\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao aceitar solicitação:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async rejectFriendRequest(requestId) {\r\n        try {\r\n            const docRef = doc(db, 'friends', requestId);\r\n            await updateDoc(docRef, {\r\n                status: 'REJECTED'\r\n            });\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao rejeitar solicitação:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async getFriends(userId) {\r\n        try {\r\n            const q = query(collection(db, 'friends'), where('status', '==', 'ACCEPTED'));\r\n            const querySnapshot = await getDocs(q);\r\n            const allFriends = querySnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n            // Filtrar amigos do usuário (pode estar em userId ou friendId)\r\n            return allFriends.filter(friend => friend.userId === userId || friend.friendId === userId);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar amigos:', error);\r\n            return [];\r\n        }\r\n    }\r\n    async removeFriend(friendshipId) {\r\n        try {\r\n            const docRef = doc(db, 'friends', friendshipId);\r\n            await deleteDoc(docRef);\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao remover amigo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async areFriends(user1Id, user2Id) {\r\n        try {\r\n            const q = query(collection(db, 'friends'), where('status', '==', 'ACCEPTED'));\r\n            const querySnapshot = await getDocs(q);\r\n            const friendships = querySnapshot.docs.map(doc => doc.data());\r\n            return friendships.some(f => (f.userId === user1Id && f.friendId === user2Id) ||\r\n                (f.userId === user2Id && f.friendId === user1Id));\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao verificar amizade:', error);\r\n            return false;\r\n        }\r\n    }\r\n    async searchUsers(searchTerm, currentUserId) {\r\n        try {\r\n            const usersSnapshot = await getDocs(collection(db, 'users'));\r\n            const users = usersSnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n            // Filtrar usuários que correspondem à busca (exceto o próprio usuário)\r\n            return users.filter(user => user.id !== currentUserId &&\r\n                user.userType === 'PLAYER' &&\r\n                (user.username.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n                    user.email.toLowerCase().includes(searchTerm.toLowerCase())));\r\n        }\r\n        catch (error) {\r\n            console.error('Erro ao buscar usuários:', error);\r\n            return [];\r\n        }\r\n    }\r\n}\r\nFriendService.ɵfac = function FriendService_Factory(t) { return new (t || FriendService)(); };\r\nFriendService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: FriendService, factory: FriendService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}