{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { environment } from '../../environments/environment';\nimport { getFirestore, collection, doc, setDoc, getDoc, getDocs, deleteDoc, updateDoc } from 'firebase/firestore';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ItemService = /*#__PURE__*/(() => {\n  class ItemService {\n    constructor(http) {\n      this.http = http;\n      this.db = getFirestore();\n    }\n\n    createItem(item) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const result = yield _this.http.post(`${environment.backendUrl}/items`, item).toPromise();\n        return result.id;\n      })();\n    }\n\n    getAllItems() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        return yield _this2.http.get(`${environment.backendUrl}/items`).toPromise();\n      })();\n    }\n\n    getItemsByBox(boxId) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        return yield _this3.http.get(`${environment.backendUrl}/items/by-box/${boxId}`).toPromise();\n      })();\n    }\n\n    getItemById(itemId) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        const data = yield _this4.http.get(`${environment.backendUrl}/items/${itemId}`).toPromise();\n        return data ? Object.assign({\n          id: itemId\n        }, data) : null;\n      })();\n    }\n\n    updateItem(itemId, data) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this5.http.put(`${environment.backendUrl}/items/${itemId}`, data).toPromise();\n      })();\n    } // Função auxiliar para calcular pontos baseado na raridade e rarityLevel\n\n\n    calculateItemPoints(rarity, rarityLevel) {\n      const rarityPoints = {\n        'COMUM': 10,\n        'RARO': 25,\n        'EPICO': 50,\n        'LENDARIO': 100,\n        'MITICO': 200\n      };\n      let points = rarityPoints[rarity] || 10; // Aplicar multiplicador baseado no rarityLevel se existir\n\n      if (rarityLevel && typeof rarityLevel === 'number') {\n        const rarityMultiplier = 1 + (1000 - rarityLevel) / 1000;\n        points = Math.round(points * rarityMultiplier);\n      }\n\n      return points;\n    }\n\n    migrateItemsWithoutPoints() {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* (forceRecalculate = false) {\n        // Busca todos os documentos diretamente do Firestore para verificar campos brutos\n        const querySnapshot = yield getDocs(collection(_this6.db, 'items'));\n        const itemsToUpdate = [];\n        const allItems = [];\n        const mode = forceRecalculate ? '(MODO FORÇADO - RECALCULAR TODOS)' : '';\n        console.log(`Verificando todos os itens no banco... ${mode}`);\n        querySnapshot.forEach(doc => {\n          const data = doc.data();\n          allItems.push({\n            id: doc.id,\n            name: data.name,\n            rarity: data.rarity,\n            rarityLevel: data.rarityLevel,\n            points: data.points,\n            hasPointsField: data.hasOwnProperty('points')\n          }); // Se for modo forçado, recalcular todos os itens\n\n          if (forceRecalculate) {\n            itemsToUpdate.push(Object.assign({\n              id: doc.id\n            }, data));\n          } else {\n            // Modo normal: só itens sem pontos válidos\n            const needsMigration = !data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0;\n\n            if (needsMigration) {\n              itemsToUpdate.push(Object.assign({\n                id: doc.id\n              }, data));\n            }\n          }\n        });\n        console.log('Todos os itens encontrados:', allItems);\n        console.log(`Encontrados ${itemsToUpdate.length} itens para atualizar pontos`);\n\n        if (itemsToUpdate.length === 0 && !forceRecalculate) {\n          console.log('Nenhum item precisa de migracao. Verificando se ha itens com points = 0...'); // Verificar especificamente itens com points = 0\n\n          const itemsWithZeroPoints = allItems.filter(item => item.points === 0);\n\n          if (itemsWithZeroPoints.length > 0) {\n            console.log('Encontrados itens com points = 0. Forcando migracao...', itemsWithZeroPoints); // Adicionar itens com points = 0 à lista de atualização\n\n            querySnapshot.forEach(doc => {\n              const data = doc.data();\n\n              if (data.points === 0) {\n                itemsToUpdate.push(Object.assign({\n                  id: doc.id\n                }, data));\n              }\n            });\n          } else {\n            console.log('Todos os itens ja tem pontos validos (> 0).');\n            console.log('Dica: Use migrateItemsWithoutPoints(true) para forcar recalculo de todos os pontos.');\n            return;\n          }\n        } // Define pontos baseados na raridade\n\n\n        const rarityPoints = {\n          'COMUM': 10,\n          'RARO': 25,\n          'EPICO': 50,\n          'LENDARIO': 100,\n          'MITICO': 200\n        };\n\n        for (const itemData of itemsToUpdate) {\n          console.log(`Processando item: ${itemData.name}`, {\n            rarity: itemData.rarity,\n            rarityLevel: itemData.rarityLevel,\n            hasRarityLevel: itemData.hasOwnProperty('rarityLevel'),\n            rarityLevelType: typeof itemData.rarityLevel\n          });\n          let points = rarityPoints[itemData.rarity] || 10;\n          console.log(`Pontos base calculados: ${points} para raridade ${itemData.rarity}`); // Aplicar multiplicador baseado no rarityLevel PARA TODOS os itens\n\n          if (itemData.rarityLevel && typeof itemData.rarityLevel === 'number') {\n            const rarityMultiplier = 1 + (1000 - itemData.rarityLevel) / 1000; // 1.0 a 2.0\n\n            const oldPoints = points;\n            points = Math.round(points * rarityMultiplier);\n            console.log(`Aplicando multiplicador: ${oldPoints} x ${rarityMultiplier.toFixed(3)} = ${points} (rarityLevel: ${itemData.rarityLevel})`);\n          } else {\n            console.log(`Sem rarityLevel ou invalido: ${itemData.rarityLevel}`);\n          }\n\n          console.log(`Salvando item ${itemData.name} com ${points} pontos`);\n          yield _this6.updateItem(itemData.id, {\n            points\n          });\n          console.log(`Atualizado item ${itemData.name} com points = ${points}`);\n        }\n\n        console.log('Migração concluída');\n      }).apply(this, arguments);\n    }\n\n    migrateUserItemsPoints() {\n      var _this7 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        console.log('Iniciando migracao de pontos para userItems...'); // Buscar todos os userItems\n\n        const querySnapshot = yield getDocs(collection(_this7.db, 'userItems'));\n        const userItemsToUpdate = [];\n        querySnapshot.forEach(doc => {\n          const data = doc.data(); // Verificar se não tem pontos ou pontos = 0\n\n          if (!data.hasOwnProperty('points') || data.points === null || data.points === undefined || data.points === 0) {\n            userItemsToUpdate.push(Object.assign({\n              id: doc.id\n            }, data));\n          }\n        });\n        console.log(`Encontrados ${userItemsToUpdate.length} userItems para atualizar pontos`);\n\n        if (userItemsToUpdate.length === 0) {\n          console.log('Todos os userItems ja tem pontos validos.');\n          return;\n        }\n\n        for (const userItemData of userItemsToUpdate) {\n          // Se não tem item aninhado, buscar pelo itemId\n          let itemRarity = (_a = userItemData.item) === null || _a === void 0 ? void 0 : _a.rarity;\n\n          if (!itemRarity && userItemData.itemId) {\n            const item = yield _this7.getItemById(userItemData.itemId);\n            itemRarity = item === null || item === void 0 ? void 0 : item.rarity;\n          }\n\n          if (!itemRarity) {\n            console.log(`Nao foi possivel determinar raridade para userItem ${userItemData.id}`);\n            continue;\n          }\n\n          const points = _this7.calculateItemPoints(itemRarity, userItemData.rarityLevel);\n\n          console.log(`Migrando userItem ${userItemData.id}: raridade ${itemRarity}, rarityLevel ${userItemData.rarityLevel}, pontos ${points}`);\n          yield updateDoc(doc(_this7.db, 'userItems', userItemData.id), {\n            points\n          });\n          console.log(`Atualizado userItem ${userItemData.id} com points = ${points}`);\n        }\n\n        console.log('Migracao de userItems concluida!');\n      })();\n    }\n\n    deleteItem(itemId) {\n      var _this8 = this;\n\n      return _asyncToGenerator(function* () {\n        const docRef = doc(_this8.db, 'items', itemId);\n        yield deleteDoc(docRef);\n      })();\n    }\n\n    deleteAllItems() {\n      var _this9 = this;\n\n      return _asyncToGenerator(function* () {\n        console.log('Deletando todos os itens...');\n        const items = yield _this9.getAllItems();\n        console.log(`Encontrados ${items.length} itens para deletar`);\n\n        for (const item of items) {\n          console.log(`Deletando ${item.name}...`);\n          yield _this9.deleteItem(item.id);\n        }\n\n        console.log('Todos os itens foram deletados!');\n      })();\n    }\n\n    addItemToUser(userId, itemId, rarityLevel) {\n      var _this0 = this;\n\n      return _asyncToGenerator(function* () {\n        const item = yield _this0.getItemById(itemId);\n        if (!item) throw new Error('Item não encontrado'); // Para itens lendários e míticos, garantir rarityLevel único\n\n        let finalRarityLevel;\n\n        if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\n          if (rarityLevel) {\n            // Verificar se o rarityLevel fornecido já existe para este item\n            const exists = yield _this0.checkRarityLevelExists(itemId, rarityLevel, userId);\n\n            if (exists) {\n              throw new Error('Este nível de raridade já existe para este item');\n            }\n\n            finalRarityLevel = rarityLevel;\n          } else {\n            // Gerar rarityLevel único\n            finalRarityLevel = yield _this0.generateUniqueRarityLevel(itemId, userId);\n          }\n        } else {\n          // Para outros itens, usar o rarityLevel fornecido ou gerar aleatório\n          finalRarityLevel = rarityLevel !== null && rarityLevel !== void 0 ? rarityLevel : Math.floor(Math.random() * 1000) + 1;\n        } // Calcular pontos baseado na raridade e rarityLevel\n\n\n        const points = _this0.calculateItemPoints(item.rarity, finalRarityLevel); // Para itens lendários e míticos, cada cópia é tratada como item único\n\n\n        if (item.rarity === 'LENDARIO' || item.rarity === 'MITICO') {\n          // Criar entrada única para cada item lendário/mítico\n          const uniqueId = `${userId}_${itemId}_${Date.now()}_${finalRarityLevel}`;\n          const docRef = doc(_this0.db, 'userItems', uniqueId);\n          const userItemData = {\n            userId,\n            itemId,\n            item,\n            obtainedAt: new Date(),\n            quantity: 1,\n            rarityLevel: finalRarityLevel,\n            points\n          };\n          yield setDoc(docRef, userItemData);\n          return finalRarityLevel;\n        } else {\n          // Para itens comuns, raros e épicos, manter o sistema atual\n          const userItemId = `${userId}_${itemId}`;\n          const docRef = doc(_this0.db, 'userItems', userItemId);\n          const docSnap = yield getDoc(docRef);\n\n          if (docSnap.exists()) {\n            const currentData = docSnap.data();\n            yield updateDoc(docRef, {\n              quantity: currentData['quantity'] + 1,\n              points: Math.max(currentData['points'] || 0, points)\n            });\n            return 0; // No rarity level for common items\n          } else {\n            const userItemData = {\n              userId,\n              itemId,\n              item,\n              obtainedAt: new Date(),\n              quantity: 1,\n              points\n            };\n            yield setDoc(docRef, userItemData);\n            return 0;\n          }\n        }\n      })();\n    }\n\n    getUserItems(userId) {\n      var _this1 = this;\n\n      return _asyncToGenerator(function* () {\n        const data = yield _this1.http.get(`${environment.backendUrl}/userItems/user/${userId}`).toPromise();\n        const userItems = yield Promise.all(data.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (ui) {\n            const item = yield _this1.getItemById(ui.itemId);\n            return Object.assign(Object.assign({\n              id: ui.id\n            }, ui), {\n              item\n            });\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n        return userItems;\n      })();\n    }\n\n    getUserItemById(id) {\n      var _this10 = this;\n\n      return _asyncToGenerator(function* () {\n        const data = yield _this10.http.get(`${environment.backendUrl}/userItems/${id}`).toPromise();\n\n        if (data) {\n          const item = yield _this10.getItemById(data.itemId);\n          return Object.assign(Object.assign({\n            id\n          }, data), {\n            item\n          });\n        }\n\n        return null;\n      })();\n    }\n\n    getUserRarestItemInBox(userId, boxId) {\n      var _this11 = this;\n\n      return _asyncToGenerator(function* () {\n        const userItems = yield _this11.getUserItems(userId);\n        const boxItems = userItems.filter(ui => ui.item.boxId === boxId);\n        if (boxItems.length === 0) return null;\n        boxItems.sort((a, b) => {\n          // Calcular score baseado na raridade e rarityLevel\n          let scoreA = a.item.points || 0;\n          let scoreB = b.item.points || 0; // Para itens lendários e míticos, aplicar multiplicador do rarityLevel\n\n          if ((a.item.rarity === 'LENDARIO' || a.item.rarity === 'MITICO') && a.rarityLevel) {\n            const rarityMultiplierA = 1 + (1000 - a.rarityLevel) / 1000;\n            scoreA = scoreA * rarityMultiplierA;\n          }\n\n          if ((b.item.rarity === 'LENDARIO' || b.item.rarity === 'MITICO') && b.rarityLevel) {\n            const rarityMultiplierB = 1 + (1000 - b.rarityLevel) / 1000;\n            scoreB = scoreB * rarityMultiplierB;\n          }\n\n          return scoreB - scoreA; // Ordenação decrescente\n        });\n        return boxItems[0];\n      })();\n    } // Verificar se um rarityLevel já existe para um item específico\n\n\n    checkRarityLevelExists(itemId, rarityLevel, excludeUserId) {\n      var _this12 = this;\n\n      return _asyncToGenerator(function* () {\n        const params = excludeUserId ? `?excludeUserId=${excludeUserId}` : '';\n        const result = yield _this12.http.get(`${environment.backendUrl}/userItems/check-rarity/${itemId}/${rarityLevel}${params}`).toPromise();\n        return result.exists;\n      })();\n    } // Gerar um rarityLevel único para um item\n\n\n    generateUniqueRarityLevel(itemId, userId) {\n      var _this13 = this;\n\n      return _asyncToGenerator(function* () {\n        const maxAttempts = 1000; // Evitar loop infinito\n\n        let attempts = 0;\n\n        while (attempts < maxAttempts) {\n          const rarityLevel = Math.floor(Math.random() * 1000) + 1;\n          const exists = yield _this13.checkRarityLevelExists(itemId, rarityLevel, userId);\n\n          if (!exists) {\n            return rarityLevel;\n          }\n\n          attempts++;\n        } // Se não conseguir gerar único após muitas tentativas, usar timestamp como base\n\n\n        const timestampBased = Date.now() % 1000 + 1;\n        return Math.min(timestampBased, 1000);\n      })();\n    }\n\n    drawRandomItem(boxId) {\n      var _this14 = this;\n\n      return _asyncToGenerator(function* () {\n        const items = yield _this14.getItemsByBox(boxId);\n        if (items.length === 0) throw new Error('Nenhum item disponível nesta caixa'); // Usar as taxas de drop configuradas para cada item\n\n        const totalDropRate = items.reduce((sum, item) => sum + (item.dropRate || 0), 0);\n\n        if (totalDropRate === 0) {\n          throw new Error('As taxas de drop dos itens não foram configuradas corretamente');\n        } // Gerar número aleatório entre 0 e o total de taxas\n\n\n        const random = Math.random() * totalDropRate; // Selecionar item baseado na taxa de drop\n\n        let currentSum = 0;\n\n        for (const item of items) {\n          currentSum += item.dropRate || 0;\n\n          if (random <= currentSum) {\n            return item;\n          }\n        } // Fallback (não deveria acontecer, mas por segurança)\n\n\n        return items[items.length - 1];\n      })();\n    }\n\n    removeItemFromUser(_x2) {\n      var _this15 = this;\n\n      return _asyncToGenerator(function* (userItemId, quantity = 1) {\n        yield _this15.http.post(`${environment.backendUrl}/userItems/${userItemId}/remove`, {\n          quantity\n        }).toPromise();\n      }).apply(this, arguments);\n    }\n\n  }\n\n  ItemService.ɵfac = function ItemService_Factory(t) {\n    return new (t || ItemService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  ItemService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ItemService,\n    factory: ItemService.ɵfac,\n    providedIn: 'root'\n  });\n  return ItemService;\n})();","map":null,"metadata":{},"sourceType":"module"}