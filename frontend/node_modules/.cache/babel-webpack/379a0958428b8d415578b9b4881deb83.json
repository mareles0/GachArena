{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { collection, doc, getDoc, getDocs, query, where, updateDoc, deleteDoc, addDoc, runTransaction, writeBatch } from 'firebase/firestore';\nimport { db } from '../firebase.config';\nimport * as i0 from \"@angular/core\";\nexport class TradeService {\n  constructor() {}\n\n  createTrade(trade) {\n    return _asyncToGenerator(function* () {\n      const tradeData = Object.assign(Object.assign({}, trade), {\n        status: 'PENDING',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      });\n      const docRef = yield addDoc(collection(db, 'trades'), tradeData);\n      return docRef.id;\n    })();\n  }\n\n  getTradeById(tradeId) {\n    return _asyncToGenerator(function* () {\n      const docRef = doc(db, 'trades', tradeId);\n      const docSnap = yield getDoc(docRef);\n\n      if (docSnap.exists()) {\n        return Object.assign({\n          id: docSnap.id\n        }, docSnap.data());\n      }\n\n      return null;\n    })();\n  }\n\n  getUserSentTrades(userId) {\n    return _asyncToGenerator(function* () {\n      const q = query(collection(db, 'trades'), where('fromUserId', '==', userId));\n      const querySnapshot = yield getDocs(q);\n      return querySnapshot.docs.map(doc => Object.assign({\n        id: doc.id\n      }, doc.data()));\n    })();\n  }\n\n  getUserReceivedTrades(userId) {\n    return _asyncToGenerator(function* () {\n      const q = query(collection(db, 'trades'), where('toUserId', '==', userId));\n      const querySnapshot = yield getDocs(q);\n      return querySnapshot.docs.map(doc => Object.assign({\n        id: doc.id\n      }, doc.data()));\n    })();\n  }\n\n  acceptTrade(tradeId) {\n    return _asyncToGenerator(function* () {\n      // Ao aceitar, validar posses e trocar ownership dos userItems de forma atômica\n      const tradeRef = doc(db, 'trades', tradeId);\n      yield runTransaction(db, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (tx) {\n          const tradeSnap = yield tx.get(tradeRef);\n          if (!tradeSnap.exists()) throw new Error('Trade não encontrado');\n          const trade = tradeSnap.data();\n          if (trade.status !== 'PENDING') throw new Error('Trade já processado');\n          const fromUserId = trade.fromUserId;\n          const toUserId = trade.toUserId; // Ler todos os userItems envolvidos\n\n          const allUserItemIds = [...(trade.offeredUserItemIds || []), ...(trade.requestedUserItemIds || [])];\n          const userItemSnaps = yield Promise.all(allUserItemIds.map(id => getDoc(doc(db, 'userItems', id)))); // Validar propriedade\n\n          for (const id of trade.offeredUserItemIds) {\n            const snap = userItemSnaps.find(s => s && s.id === id);\n            if (!snap || !snap.exists()) throw new Error('Item oferecido não encontrado: ' + id);\n            const data = snap.data();\n            if (data.userId !== fromUserId) throw new Error('O usuário não possui o item oferecido: ' + id);\n          }\n\n          for (const id of trade.requestedUserItemIds) {\n            const snap = userItemSnaps.find(s => s && s.id === id);\n            if (!snap || !snap.exists()) throw new Error('Item solicitado não encontrado: ' + id);\n            const data = snap.data();\n            if (data.userId !== toUserId) throw new Error('O usuário não possui o item solicitado: ' + id);\n          } // Coletar userItemIds transferidos para limpar showcasedCards\n\n\n          const transferredUserItemIds = new Set([...trade.offeredUserItemIds, ...trade.requestedUserItemIds]);\n          console.log('acceptTrade - transferredUserItemIds:', Array.from(transferredUserItemIds)); // Realizar transferências (simples: atualizar userId ou ajustar quantities)\n          // Usar batch para operações de escrita\n\n          const batch = writeBatch(db); // Transferir oferecidos -> toUserId\n\n          for (const id of trade.offeredUserItemIds) {\n            const ref = doc(db, 'userItems', id);\n            const snap = userItemSnaps.find(s => s && s.id === id);\n            const data = snap.data();\n\n            if (data.quantity && data.quantity > 1) {\n              // decrementar quantidade no documento origem\n              batch.update(ref, {\n                quantity: data.quantity - 1\n              }); // incrementar/crear doc destino (toUserId_itemId)\n\n              const destId = `${toUserId}_${data.itemId}`;\n              const destRef = doc(db, 'userItems', destId);\n              const destSnap = yield getDoc(destRef);\n\n              if (destSnap.exists()) {\n                batch.update(destRef, {\n                  quantity: destSnap.data().quantity + 1\n                });\n              } else {\n                batch.set(destRef, {\n                  userId: toUserId,\n                  itemId: data.itemId,\n                  item: data.item,\n                  obtainedAt: new Date(),\n                  quantity: 1\n                });\n              }\n            } else {\n              // quantidade == 1 -> mudar dono (atualizar userId)\n              batch.update(ref, {\n                userId: toUserId,\n                obtainedAt: new Date()\n              });\n            }\n          } // Transferir solicitados -> fromUserId\n\n\n          for (const id of trade.requestedUserItemIds) {\n            const ref = doc(db, 'userItems', id);\n            const snap = userItemSnaps.find(s => s && s.id === id);\n            const data = snap.data();\n\n            if (data.quantity && data.quantity > 1) {\n              batch.update(ref, {\n                quantity: data.quantity - 1\n              });\n              const destId = `${fromUserId}_${data.itemId}`;\n              const destRef = doc(db, 'userItems', destId);\n              const destSnap = yield getDoc(destRef);\n\n              if (destSnap.exists()) {\n                batch.update(destRef, {\n                  quantity: destSnap.data().quantity + 1\n                });\n              } else {\n                batch.set(destRef, {\n                  userId: fromUserId,\n                  itemId: data.itemId,\n                  item: data.item,\n                  obtainedAt: new Date(),\n                  quantity: 1\n                });\n              }\n            } else {\n              batch.update(ref, {\n                userId: fromUserId,\n                obtainedAt: new Date()\n              });\n            }\n          } // Limpar showcasedCards dos usuários envolvidos\n\n\n          const fromUserRef = doc(db, 'users', fromUserId);\n          const toUserRef = doc(db, 'users', toUserId);\n          const fromUserSnap = yield tx.get(fromUserRef);\n          const toUserSnap = yield tx.get(toUserRef);\n\n          if (fromUserSnap.exists()) {\n            const fromUserData = fromUserSnap.data();\n            const currentShowcased = fromUserData.showcasedCards || [];\n            const filteredShowcased = currentShowcased.filter(userItemId => !transferredUserItemIds.has(userItemId));\n            console.log('acceptTrade - fromUser showcasedCards:', {\n              before: currentShowcased,\n              after: filteredShowcased\n            });\n\n            if (filteredShowcased.length !== currentShowcased.length) {\n              batch.update(fromUserRef, {\n                showcasedCards: filteredShowcased\n              });\n            }\n          }\n\n          if (toUserSnap.exists()) {\n            const toUserData = toUserSnap.data();\n            const currentShowcased = toUserData.showcasedCards || [];\n            const filteredShowcased = currentShowcased.filter(userItemId => !transferredUserItemIds.has(userItemId));\n            console.log('acceptTrade - toUser showcasedCards:', {\n              before: currentShowcased,\n              after: filteredShowcased\n            });\n\n            if (filteredShowcased.length !== currentShowcased.length) {\n              batch.update(toUserRef, {\n                showcasedCards: filteredShowcased\n              });\n            }\n          } // Atualizar trade status\n\n\n          batch.update(tradeRef, {\n            status: 'ACCEPTED',\n            updatedAt: new Date()\n          }); // Commit batch\n\n          yield batch.commit();\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  rejectTrade(tradeId) {\n    return _asyncToGenerator(function* () {\n      const docRef = doc(db, 'trades', tradeId);\n      yield updateDoc(docRef, {\n        status: 'REJECTED',\n        updatedAt: new Date()\n      });\n    })();\n  }\n\n  cancelTrade(tradeId) {\n    return _asyncToGenerator(function* () {\n      const docRef = doc(db, 'trades', tradeId);\n      yield updateDoc(docRef, {\n        status: 'CANCELLED',\n        updatedAt: new Date()\n      });\n    })();\n  }\n\n  deleteTrade(tradeId) {\n    return _asyncToGenerator(function* () {\n      yield deleteDoc(doc(db, 'trades', tradeId));\n    })();\n  }\n\n}\n\nTradeService.ɵfac = function TradeService_Factory(t) {\n  return new (t || TradeService)();\n};\n\nTradeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TradeService,\n  factory: TradeService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:/Users/olimp/OneDrive/Documentos/estagio/Estagio-etapa-3/GachArena/frontend/src/app/services/trade.service.ts"],"names":["collection","doc","getDoc","getDocs","query","where","updateDoc","deleteDoc","addDoc","runTransaction","writeBatch","db","i0","TradeService","constructor","createTrade","trade","tradeData","Object","assign","status","createdAt","Date","updatedAt","docRef","id","getTradeById","tradeId","docSnap","exists","data","getUserSentTrades","userId","q","querySnapshot","docs","map","getUserReceivedTrades","acceptTrade","tradeRef","tx","tradeSnap","get","Error","fromUserId","toUserId","allUserItemIds","offeredUserItemIds","requestedUserItemIds","userItemSnaps","Promise","all","snap","find","s","transferredUserItemIds","Set","console","log","Array","from","batch","ref","quantity","update","destId","itemId","destRef","destSnap","set","item","obtainedAt","fromUserRef","toUserRef","fromUserSnap","toUserSnap","fromUserData","currentShowcased","showcasedCards","filteredShowcased","filter","userItemId","has","before","after","length","toUserData","commit","rejectTrade","cancelTrade","deleteTrade","ɵfac","TradeService_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { collection, doc, getDoc, getDocs, query, where, updateDoc, deleteDoc, addDoc, runTransaction, writeBatch } from 'firebase/firestore';\r\nimport { db } from '../firebase.config';\r\nimport * as i0 from \"@angular/core\";\r\nexport class TradeService {\r\n    constructor() { }\r\n    async createTrade(trade) {\r\n        const tradeData = Object.assign(Object.assign({}, trade), { status: 'PENDING', createdAt: new Date(), updatedAt: new Date() });\r\n        const docRef = await addDoc(collection(db, 'trades'), tradeData);\r\n        return docRef.id;\r\n    }\r\n    async getTradeById(tradeId) {\r\n        const docRef = doc(db, 'trades', tradeId);\r\n        const docSnap = await getDoc(docRef);\r\n        if (docSnap.exists()) {\r\n            return Object.assign({ id: docSnap.id }, docSnap.data());\r\n        }\r\n        return null;\r\n    }\r\n    async getUserSentTrades(userId) {\r\n        const q = query(collection(db, 'trades'), where('fromUserId', '==', userId));\r\n        const querySnapshot = await getDocs(q);\r\n        return querySnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n    }\r\n    async getUserReceivedTrades(userId) {\r\n        const q = query(collection(db, 'trades'), where('toUserId', '==', userId));\r\n        const querySnapshot = await getDocs(q);\r\n        return querySnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));\r\n    }\r\n    async acceptTrade(tradeId) {\r\n        // Ao aceitar, validar posses e trocar ownership dos userItems de forma atômica\r\n        const tradeRef = doc(db, 'trades', tradeId);\r\n        await runTransaction(db, async (tx) => {\r\n            const tradeSnap = await tx.get(tradeRef);\r\n            if (!tradeSnap.exists())\r\n                throw new Error('Trade não encontrado');\r\n            const trade = tradeSnap.data();\r\n            if (trade.status !== 'PENDING')\r\n                throw new Error('Trade já processado');\r\n            const fromUserId = trade.fromUserId;\r\n            const toUserId = trade.toUserId;\r\n            // Ler todos os userItems envolvidos\r\n            const allUserItemIds = [...(trade.offeredUserItemIds || []), ...(trade.requestedUserItemIds || [])];\r\n            const userItemSnaps = await Promise.all(allUserItemIds.map(id => getDoc(doc(db, 'userItems', id))));\r\n            // Validar propriedade\r\n            for (const id of trade.offeredUserItemIds) {\r\n                const snap = userItemSnaps.find(s => s && s.id === id);\r\n                if (!snap || !snap.exists())\r\n                    throw new Error('Item oferecido não encontrado: ' + id);\r\n                const data = snap.data();\r\n                if (data.userId !== fromUserId)\r\n                    throw new Error('O usuário não possui o item oferecido: ' + id);\r\n            }\r\n            for (const id of trade.requestedUserItemIds) {\r\n                const snap = userItemSnaps.find(s => s && s.id === id);\r\n                if (!snap || !snap.exists())\r\n                    throw new Error('Item solicitado não encontrado: ' + id);\r\n                const data = snap.data();\r\n                if (data.userId !== toUserId)\r\n                    throw new Error('O usuário não possui o item solicitado: ' + id);\r\n            }\r\n            // Coletar userItemIds transferidos para limpar showcasedCards\r\n            const transferredUserItemIds = new Set([...trade.offeredUserItemIds, ...trade.requestedUserItemIds]);\r\n            console.log('acceptTrade - transferredUserItemIds:', Array.from(transferredUserItemIds));\r\n            // Realizar transferências (simples: atualizar userId ou ajustar quantities)\r\n            // Usar batch para operações de escrita\r\n            const batch = writeBatch(db);\r\n            // Transferir oferecidos -> toUserId\r\n            for (const id of trade.offeredUserItemIds) {\r\n                const ref = doc(db, 'userItems', id);\r\n                const snap = userItemSnaps.find(s => s && s.id === id);\r\n                const data = snap.data();\r\n                if (data.quantity && data.quantity > 1) {\r\n                    // decrementar quantidade no documento origem\r\n                    batch.update(ref, { quantity: data.quantity - 1 });\r\n                    // incrementar/crear doc destino (toUserId_itemId)\r\n                    const destId = `${toUserId}_${data.itemId}`;\r\n                    const destRef = doc(db, 'userItems', destId);\r\n                    const destSnap = await getDoc(destRef);\r\n                    if (destSnap.exists()) {\r\n                        batch.update(destRef, { quantity: destSnap.data().quantity + 1 });\r\n                    }\r\n                    else {\r\n                        batch.set(destRef, { userId: toUserId, itemId: data.itemId, item: data.item, obtainedAt: new Date(), quantity: 1 });\r\n                    }\r\n                }\r\n                else {\r\n                    // quantidade == 1 -> mudar dono (atualizar userId)\r\n                    batch.update(ref, { userId: toUserId, obtainedAt: new Date() });\r\n                }\r\n            }\r\n            // Transferir solicitados -> fromUserId\r\n            for (const id of trade.requestedUserItemIds) {\r\n                const ref = doc(db, 'userItems', id);\r\n                const snap = userItemSnaps.find(s => s && s.id === id);\r\n                const data = snap.data();\r\n                if (data.quantity && data.quantity > 1) {\r\n                    batch.update(ref, { quantity: data.quantity - 1 });\r\n                    const destId = `${fromUserId}_${data.itemId}`;\r\n                    const destRef = doc(db, 'userItems', destId);\r\n                    const destSnap = await getDoc(destRef);\r\n                    if (destSnap.exists()) {\r\n                        batch.update(destRef, { quantity: destSnap.data().quantity + 1 });\r\n                    }\r\n                    else {\r\n                        batch.set(destRef, { userId: fromUserId, itemId: data.itemId, item: data.item, obtainedAt: new Date(), quantity: 1 });\r\n                    }\r\n                }\r\n                else {\r\n                    batch.update(ref, { userId: fromUserId, obtainedAt: new Date() });\r\n                }\r\n            }\r\n            // Limpar showcasedCards dos usuários envolvidos\r\n            const fromUserRef = doc(db, 'users', fromUserId);\r\n            const toUserRef = doc(db, 'users', toUserId);\r\n            const fromUserSnap = await tx.get(fromUserRef);\r\n            const toUserSnap = await tx.get(toUserRef);\r\n            if (fromUserSnap.exists()) {\r\n                const fromUserData = fromUserSnap.data();\r\n                const currentShowcased = fromUserData.showcasedCards || [];\r\n                const filteredShowcased = currentShowcased.filter((userItemId) => !transferredUserItemIds.has(userItemId));\r\n                console.log('acceptTrade - fromUser showcasedCards:', { before: currentShowcased, after: filteredShowcased });\r\n                if (filteredShowcased.length !== currentShowcased.length) {\r\n                    batch.update(fromUserRef, { showcasedCards: filteredShowcased });\r\n                }\r\n            }\r\n            if (toUserSnap.exists()) {\r\n                const toUserData = toUserSnap.data();\r\n                const currentShowcased = toUserData.showcasedCards || [];\r\n                const filteredShowcased = currentShowcased.filter((userItemId) => !transferredUserItemIds.has(userItemId));\r\n                console.log('acceptTrade - toUser showcasedCards:', { before: currentShowcased, after: filteredShowcased });\r\n                if (filteredShowcased.length !== currentShowcased.length) {\r\n                    batch.update(toUserRef, { showcasedCards: filteredShowcased });\r\n                }\r\n            }\r\n            // Atualizar trade status\r\n            batch.update(tradeRef, { status: 'ACCEPTED', updatedAt: new Date() });\r\n            // Commit batch\r\n            await batch.commit();\r\n        });\r\n    }\r\n    async rejectTrade(tradeId) {\r\n        const docRef = doc(db, 'trades', tradeId);\r\n        await updateDoc(docRef, {\r\n            status: 'REJECTED',\r\n            updatedAt: new Date()\r\n        });\r\n    }\r\n    async cancelTrade(tradeId) {\r\n        const docRef = doc(db, 'trades', tradeId);\r\n        await updateDoc(docRef, {\r\n            status: 'CANCELLED',\r\n            updatedAt: new Date()\r\n        });\r\n    }\r\n    async deleteTrade(tradeId) {\r\n        await deleteDoc(doc(db, 'trades', tradeId));\r\n    }\r\n}\r\nTradeService.ɵfac = function TradeService_Factory(t) { return new (t || TradeService)(); };\r\nTradeService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TradeService, factory: TradeService.ɵfac, providedIn: 'root' });\r\n"]},"metadata":{},"sourceType":"module"}